#####################################
library(Seurat)       # For single-cell analysis
library(dplyr)        # For data manipulation
library(harmony)
library(ggplot2)      # For visualization
###read data
data.tables <- list()
data.tables[[1]] <- read.table("S1_matrix.tsv.gz",header = TRUE, row.names = 1, sep = "\t")
data.tables[[2]]  <- read.table("S2_matrix.tsv.gz",header = TRUE, row.names = 1, sep = "\t")
data.tables[[3]]  <- read.table("S3_matrix.tsv.gz",header = TRUE, row.names = 1, sep = "\t")
data.tables[[4]] <- read.table("S4_matrix.tsv.gz",header = TRUE, row.names = 1, sep = "\t")
data.tables[[5]] <- read.table("S5_matrix.tsv.gz",header = TRUE, row.names = 1, sep = "\t")
data.tables[[6]] <- read.table("S6_matrix.tsv.gz",header = TRUE, row.names = 1, sep = "\t")
#####
###
print("data merge")
samplelist<-c("S1","S2","S3","S4","S5","S6")
#groupname<-c("S1","S2","S3","S4","S5","S6") #
for (i in 1:length(samplelist)) {
   print(samplelist[i])
   samplepro <- CreateSeuratObject(counts  = data.tables[[i]], project = samplelist[i], min.cells = 5)
   samplepro <- RenameCells(samplepro,add.cell.id = samplelist[i] )
   samplepro[["sample"]] <- samplelist[i]
#  samplepro[["group"]] <- groupname[i]   ##
   mt.genes <- rownames(samplepro)[grep("^MT-",rownames(samplepro), ignore.case = TRUE)]
   samplepro[["percent.mt"]]<-PercentageFeatureSet(samplepro, features =mt.genes)
   ngenemax <- unname(quantile(samplepro$nFeature_RNA,0.95))
   umimax <- unname(quantile(samplepro$nCount_RNA,0.95))
   samplepro <- subset(samplepro, subset = nFeature_RNA > 200 & nFeature_RNA < ngenemax & percent.mt < 50 & nCount_RNA > 200 &  nCount_RNA  < umimax)
   if(i == 1){
      PRO<-samplepro
   }else{
      PRO<-merge(PRO,samplepro)
   }
}
PRO <- NormalizeData(PRO, normalization.method = "LogNormalize", scale.factor = 10000)
PRO <- FindVariableFeatures(PRO, selection.method = "vst", nfeatures = 5000)
PRO <- ScaleData(PRO,features = VariableFeatures(PRO))
PRO <- RunPCA(PRO, pc.genes = PRO@var.genes, npcs = 20, verbose = FALSE)
PRO <- RunHarmony(PRO,"sample", plot_convergence = FALSE)
PRO <- PRO %>%
    RunUMAP(reduction = "harmony", dims = 1:20) %>%
    FindNeighbors(reduction = "harmony", dims = 1:20) %>%
    FindClusters(resolution = 0.15) %>%
    identity()
PRO<-RunTSNE(PRO,reduction="harmony",dims=1:20,check_duplicates = FALSE)
print("running harmony done!")
################
DefaultAssay(PRO) <- "RNA"
ident<-as.numeric(levels(x = PRO))
new<-ident+1
###topgene#######
PRO.marker<-FindAllMarkers(PRO,only.pos=TRUE,min.pct=0.25,thresh.use=0.25)
markergenetop10<-PRO.marker %>% group_by(cluster) %>% top_n(n=10,wt=avg_logFC)
######celllabel
oldname<-c("1","2","3","4","5")  ##！！！
newname<-c("hASCs-1","hASCs-2","hASCs-3","hASCs-4","hASCs-5")  ###
names(newname)<-oldname  #
PRO<-RenameIdents(PRO,newname)  ##
PRO$cluster <- Idents(PRO)
print(levels(PRO))
#########topgene###########
PRO.marker<-FindAllMarkers(PRO,only.pos=TRUE,min.pct=0.25,thresh.use=0.25)
markergenetop10<-PRO.marker %>% group_by(cluster) %>% top_n(n=10,wt=avg_logFC)
####cluster diffgeneoutpot##########
for (l in levels(PRO)){
  cluster.markers <- FindMarkers(object=PRO,ident.1=l,min.pct=0.1,logfc.threshold = 0.25)
  write.table(data.frame(gene_id=rownames(cluster.markers),cluster.markers),file=paste(l,'_diffgenes.xls',sep=''),sep='\t',quote=F,row.names=F) }
####
FeaturePlot(PRO,features = c("GLS","BCAT1"),ncol = 3,pt.size = 0.1)
#FeaturePlot(PRO,features = c("GLS","BCAT1"),split.by ="group",ncol=2,pt.size = 0.1)  ##
VlnPlot(PRO, features = "GLS", group.by = "cluster", flip = TRUE)
#VlnPlot(PRO, features = "GLS", group.by = "group", flip = TRUE) ##
############################################
###clusterProfiler.enrich.R
##################################
library(clusterProfiler)
library(org.Hs.eg.db)  # 
library(enrichplot)
library(dplyr)
library(ggplot2)
setwd("../diffgene.Enrich") #output dir
deg <- read.table("diffgenes.xls", header = TRUE, row.names=1,sep = "\t",stringsAsFactors = FALSE)
sig_deg <- deg %>%filter(p_val_adj < 0.05 & abs(avg_log2FC) > 0.5)
sig_deg$ENTREZID <- mapIds(org.Hs.eg.db,
                          keys = sig_deg$gene,
                          column = "ENTREZID",
                          keytype = "SYMBOL",
                          multiVals = "first")
# GO
ego <- enrichGO(gene = sig_deg$ENTREZID,
                OrgDb = org.Hs.eg.db,
                keyType = "ENTREZID",
                ont = "BP",  #
                pAdjustMethod = "BH",
                qvalueCutoff = 0.05,
                readable = TRUE)
# GOplot
dotplot(ego, showCategory = 20) + ggtitle("GO Biological Process Enrichment")
barplot(ego, showCategory = 20) + ggtitle("GO Biological Process Enrichment")
# KEGGplot
ekegg <- enrichKEGG(gene = sig_deg$ENTREZID,
                   organism = "hsa",  # 
                   keyType = "kegg",
                   pAdjustMethod = "BH",
                   qvalueCutoff = 0.05)

# 
dotplot(ekegg, showCategory = 20) + ggtitle("KEGG Pathway Enrichment")
barplot(ekegg, showCategory = 20) + ggtitle("KEGG Pathway Enrichment")

# 
emapplot(ego, categorySize = "p.adjust", showCategory = 30)
emapplot(ekegg, categorySize = "p.adjust", showCategory = 20)
# 
# 
gene_list <- deg$avg_log2FC
names(gene_list) <- deg$gene
gene_list <- sort(gene_list, decreasing = TRUE)

# GSEA  GO
gsea_go <- gseGO(geneList = gene_list,
                OrgDb = org.Hs.eg.db,
                ont = "BP",
                nPerm = 1000,
                minGSSize = 10,
                maxGSSize = 500,
                pAdjustMethod = "BH",
                verbose = FALSE)

# GSEA - KEGG
gsea_kegg <- gseKEGG(geneList = gene_list,
                    organism = "hsa",
                    nPerm = 1000,
                    minGSSize = 10,
                    maxGSSize = 500,
                    pAdjustMethod = "BH",
                    verbose = FALSE)

# GSEA PLOT
gseaplot2(gsea_go, geneSetID = 1, title = head(gsea_go$Description, 1))
gseaplot2(gsea_kegg, geneSetID = 1, title = head(gsea_kegg$Description, 1))

# SAVE FILE
write.csv(as.data.frame(ego), "GO_enrichment_results.csv")
write.csv(as.data.frame(ekegg), "KEGG_enrichment_results.csv")
write.csv(as.data.frame(gsea_go), "GSEA_GO_results.csv")
write.csv(as.data.frame(gsea_kegg), "GSEA_KEGG_results.csv")
##############################
####cluster.pySCENIC.py
################################
import scanpy as sc
import anndata2ri
import pandas as pd
import numpy as np
import os
import loompy as lp
import matplotlib.pyplot as plt
from arboreto.utils import load_tf_names
from arboreto.algo import grnboost2
from pyscenic.rnkdb import FeatherRankingDatabase as RankingDatabase
from pyscenic.utils import modules_from_adjacencies, load_motifs
from pyscenic.prune import prune2df, df2regulons
from pyscenic.aucell import aucell
import seaborn as sns
import scanpy.external as sce
import subprocess
import tempfile
import shutil

# R in Python
import rpy2.robjects as ro
from rpy2.robjects import pandas2ri
from rpy2.robjects.packages import importr

# 
anndata2ri.activate()
pandas2ri.activate()

# loading R
base = importr('base')
seurat = importr('Seurat')
readr = importr('readr')

# 
os.environ['NUMEXPR_MAX_THREADS'] = '8'  
output_dir = "pyscenic_output"
os.makedirs(output_dir, exist_ok=True)
##
# 
def load_seurat_rds(rds_path):
 
    ro.r(f'seurat_obj <- readRDS("{rds_path}")')
    
    
    expr_matrix = ro.r('as.matrix(GetAssayData(seurat_obj, slot = "data"))')
    
    
    meta_data = ro.r('seurat_obj@meta.data')
    
    
    gene_names = ro.r('rownames(seurat_obj)')
    cell_names = ro.r('colnames(seurat_obj)')
    
    
    expr_df = pd.DataFrame(np.array(expr_matrix), index=gene_names, columns=cell_names)
    
    
    adata = sc.AnnData(X=expr_df.T)
    adata.obs = pd.DataFrame(meta_data)
    
    return adata

# 
print("loading Seurat data...")
adata = load_seurat_rds("PRO.rds") 

# 
sc.pp.normalize_total(adata, target_sum=1e4)
sc.pp.log1p(adata)


sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)
adata.raw = adata
adata = adata[:, adata.var.highly_variable]


expr_matrix = adata.to_df().T  

# 
expr_matrix.to_csv(f"{output_dir}/expression_matrix.csv", sep='\t')

# 
def download_database():

    if not os.path.exists("motifs-v9-nr.hgnc-m0.001-o0.0.tbl"):
        subprocess.run([
            "wget", 
            "https://resources.aertslab.org/cistarget/motif2tf/motifs-v9-nr.hgnc-m0.001-o0.0.tbl"
        ])
    
    
    if not os.path.exists("hg38__refseq-r80__10kb_up_and_down_tss.mc9nr.feather"):
        subprocess.run([
            "wget",
            "https://resources.aertslab.org/cistarget/databases/homo_sapiens/hg38/refseq_r80/mc9nr/gene_based/hg38__refseq-r80__10kb_up_and_down_tss.mc9nr.feather"
        ])
    
    
    if not os.path.exists("hs_hgnc_tfs.txt"):
        subprocess.run([
            "wget",
            "https://raw.githubusercontent.com/aertslab/pySCENIC/master/resources/hs_hgnc_tfs.txt"
        ])


download_database()


def run_pyscenic():
    
    subprocess.run([
        "pyscenic", "grn",
        f"{output_dir}/expression_matrix.csv",
        "hs_hgnc_tfs.txt",
        "-o", f"{output_dir}/adjacencies.tsv",
        "--num_workers", "8"
    ])
    
    
    databases = [
        "hg38__refseq-r80__10kb_up_and_down_tss.mc9nr.feather"
    ]
    
    subprocess.run([
        "pyscenic", "ctx",
        f"{output_dir}/adjacencies.tsv",
        *databases,
        "--annotations_fname", "motifs-v9-nr.hgnc-m0.001-o0.0.tbl",
        "--expression_mtx_fname", f"{output_dir}/expression_matrix.csv",
        "--mode", "dask_multiprocessing",
        "--output", f"{output_dir}/regulons.csv",
        "--num_workers", "8"
    ])
    
    
    subprocess.run([
        "pyscenic", "aucell",
        f"{output_dir}/expression_matrix.csv",
        f"{output_dir}/regulons.csv",
        "--output", f"{output_dir}/AUC_mtx.csv",
        "--num_workers", "8"
    ])
    
    
run_pyscenic()


def visualize_pyscenic_results():
    
    

    auc_mtx = pd.read_csv(f"{output_dir}/AUC_mtx.csv", index_col=0)
    
   
    adata.obsm['X_aucell'] = auc_mtx.loc[adata.obs_names].values
    adata.uns['aucell_regulons'] = auc_mtx.columns.tolist()
    
    
    sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)
    sc.tl.umap(adata)
    
    
    top_n = min(20, len(adata.uns['aucell_regulons']))
    top_regulons = adata.uns['aucell_regulons'][:top_n]
    
    
    plt.figure(figsize=(15, 15))
    for i, regulon in enumerate(top_regulons, 1):
        plt.subplot(5, 4, i)
        sc.pl.umap(adata, color=regulon, show=False, title=regulon)
    plt.tight_layout()
    plt.savefig(f"{output_dir}/regulon_umap.png", dpi=300)
    plt.close()
    
    
    plt.figure(figsize=(12, 10))
    sce.pl.paga(adata, color=[adata.uns['aucell_regulons'][i] for i in range(5)])
    plt.savefig(f"{output_dir}/regulon_paga.png", dpi=300)
    plt.close()
    
    
visualize_pyscenic_results()

##################################
##cellphonedb.py
###########################
import scanpy as sc
import anndata2ri
import pandas as pd
import numpy as np
import os
import subprocess
import rpy2.robjects as ro
from rpy2.robjects import pandas2ri
from rpy2.robjects.packages import importr


anndata2ri.activate()
pandas2ri.activate()


base = importr('base')
seurat = importr('Seurat')
dplyr = importr('dplyr')

output_dir = "cellphonedb_output"
os.makedirs(output_dir, exist_ok=True)


def load_seurat_rds(rds_path):

    ro.r(f'seurat_obj <- readRDS("{rds_path}")')
    
    ro.r('counts_matrix <- as.matrix(GetAssayData(seurat_obj, slot = "counts"))')
    
    ro.r('meta_data <- seurat_obj@meta.data')
    
    gene_names = ro.r('rownames(counts_matrix)')
    cell_names = ro.r('colnames(counts_matrix)')
    
    counts_df = pd.DataFrame(np.array(ro.r('counts_matrix')), 
                             index=gene_names, columns=cell_names)
    
    adata = sc.AnnData(X=counts_df.T)
    adata.obs = pd.DataFrame(ro.r('meta_data'))
    
    return adata

def prepare_cellphonedb_input(adata, cell_type_column, output_dir):
    
    expr_matrix = adata.to_df()
    
    expr_matrix.columns = [f"{gene}_{i}" if list(expr_matrix.columns).count(gene) > 1 
                          else gene for i, gene in enumerate(expr_matrix.columns)]
    
    expr_matrix.to_csv(f"{output_dir}/counts.csv", sep='\t')
    
    cell_types = adata.obs[cell_type_column]
    
    metadata = pd.DataFrame({
        'Cell': cell_types.index,
        'cell_type': cell_types.values
    })
    
    metadata.to_csv(f"{output_dir}/metadata.txt", sep='\t', na_rep='nan', index=False)
    
    return metadata


def run_cellphonedb(output_dir, method='statistical_analysis'):
    
    valid_methods = ['statistical_analysis', 'aggregate_analysis', 'cluster_analysis']
    if method not in valid_methods:
        raise ValueError(f"quit: {method}。use: {', '.join(valid_methods)}")
    
    
    cmd = [
        'cellphonedb', method,
        '--counts-data', 'gene_name',
        '--meta', f'{output_dir}/metadata.txt',
        '--counts', f'{output_dir}/counts.csv',
        '--output-path', output_dir
    ]
    
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    
    if result.returncode != 0:
        print("CellPhoneDB failed:")
        print(result.stderr)
        raise RuntimeError("CellPhoneDB failed")
    
    print(f"CellPhoneDB {method} done!")
    print(f"result : {output_dir}")
    return result.stdout

# 
def visualize_cellphonedb_results(output_dir, cell_types=None):
    
    
    try:
        
        significant_means = pd.read_csv(f"{output_dir}/significant_means.txt", sep='\t')
        
        
        interactions = significant_means[['interacting_pair', 'partner_a', 'partner_b']]
        
        
        if cell_types:
            cell_type_cols = [col for col in significant_means.columns if col.endswith('_pvalue')]
            filtered_means = significant_means.copy()
            
            for ct in cell_types:
                ct_cols = [col for col in cell_type_cols if ct in col]
                filtered_means = filtered_means[(filtered_means[ct_cols] < 0.05).any(axis=1)]
            
            interactions = filtered_means[['interacting_pair', 'partner_a', 'partner_b']]
        
        
 
        plt.figure(figsize=(12, 10))
    
        cell_type_pairs = []
        for col in significant_means.columns:
            if '_pvalue' in col:
                ct_pair = col.replace('_pvalue', '').split('|')
                cell_type_pairs.append((ct_pair[0], ct_pair[1]))
        
        
        unique_cell_types = sorted(list(set([ct for pair in cell_type_pairs for ct in pair])))
        interaction_matrix = pd.DataFrame(0, index=unique_cell_types, columns=unique_cell_types)
        
        for ct1, ct2 in cell_type_pairs:
            interaction_matrix.loc[ct1, ct2] += 1
        
        
        sns.heatmap(interaction_matrix, annot=True, cmap='viridis')
        
        plt.tight_layout()
        plt.savefig(f"{output_dir}/cell_interaction_heatmap.png", dpi=300)
        plt.close()
        
                
    except Exception as e:
        print(f"error: {e}")

#main 
def main():
    
    rds_path = "PRO.rds"  
    cell_type_column = "cluster"  
    adata = load_seurat_rds(rds_path)
    
    
    metadata = prepare_cellphonedb_input(adata, cell_type_column, output_dir)
    
    
    run_cellphonedb(output_dir, method='statistical_analysis')
    
    
    cell_types = metadata['cell_type'].unique().tolist()
    visualize_cellphonedb_results(output_dir, cell_types)
    
 

if __name__ == "__main__":
    main()

#######################
##seurat_ucell_analysis.R
###############
library(Seurat)
library(UCell)
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(GSEABase)  #
#
seurat_obj <- readRDS("./seurat_object.rds")

read_gmt <- function(file_path) {
  con <- file(file_path, "r")
  lines <- readLines(con)
  close(con)
  
  gene_sets <- list()
  for (line in lines) {
    parts <- strsplit(line, "\t")[[1]]
    if (length(parts) >= 3) {        name <- parts[1]
      genes <- parts[3:length(parts)]
      gene_sets[[name]] <- genes
    }
  }
  return(gene_sets)
}

go_gmt_file <- "./go.gmt"
gene_sets <- read_gmt(go_gmt_file)
min_genes <- 10
max_genes <- 200
valid_sets <- sapply(gene_sets, function(x) length(x) >= min_genes && length(x) <= max_genes)
gene_sets <- gene_sets[valid_sets]

seurat_obj <- AddModuleScore_UCell(
  object = seurat_obj,
  features = gene_sets,
  assay = "RNA",  
  name = "UCell_"
)
gene_set_scores <- FetchData(seurat_obj, vars = paste0("UCell_", names(gene_sets)))
cluster_averages <- gene_set_scores %>%
  cbind(Cluster = seurat_obj$seurat_clusters) %>%
  group_by(Cluster) %>%
  summarise_all(mean) %>%
  column_to_rownames(var = "Cluster")

pheatmap(
  mat = cluster_averages,
  scale = "row", 
  color = colorRampPalette(c("blue", "white", "red"))(100),
  main = "Cell Subset Gene Set Activity",
  fontsize = 10,
  fontsize_row = 12,
  fontsize_col = 12,
  cluster_rows = FALSE,  
  cluster_cols = FALSE,  
  border_color = NA,
  display_numbers = FALSE,
  number_format = "%.2f"
)
############################
##seurat_cytotrace_analysis.R
############################
library(Seurat)
library(CytoTRACE)
library(dplyr)
library(ggplot2)
seurat_obj <- readRDS("./seurat_object.rds")
counts_matrix <- GetAssayData(seurat_obj, slot = "counts", assay = "RNA")
if ("pca" %in% names(seurat_obj[["reductions"]])) {
  pca_result <- Embeddings(seurat_obj[["pca"]])
} else {
  seurat_obj <- RunPCA(seurat_obj, npcs = 50)
  pca_result <- Embeddings(seurat_obj[["pca"]])
}
cytotrace_result <- CytoTRACE(
  counts_matrix,
  reducedDims = pca_result, 
  ncores = 8,                
  threshold = 0.1            
)
seurat_obj$CytoTRACE <- cytotrace_result$CytoTRACE
seurat_obj$CytoTRACE_Rank <- cytotrace_result$CytoTRACERank
p1 <- FeaturePlot(seurat_obj, features = "CytoTRACE", reduction = "umap") +
  scale_color_viridis_c() +
  ggtitle("CytoTRACE Score")
p3 <- VlnPlot(seurat_obj, features = "CytoTRACE", group.by = "seurat_clusters", pt.size = 0) +
  ggtitle("CytoTRACE Score by Cluster")
#########################################
##seurat_scvelo_paga_analysis.py
#####################################
import scanpy as sc
import scvelo as scv
import anndata as ad
import pandas as pd
import numpy as np
import os
from rpy2.robjects import r, pandas2ri
from rpy2.robjects.conversion import localconverter

pandas2ri.activate()

seurat_rds_path = "path/to/seurat_object.rds"
bam_file_path = "path/to/sample.bam"
gtf_path = "path/to/genome.gtf"
output_dir = "scvelo_paga_results"
os.makedirs(output_dir, exist_ok=True)

def load_seurat(rds_path):
    r('''
    library(Seurat)
    library(Matrix)
    read_seurat <- function(path) {
        seur <- readRDS(path)
        counts <- GetAssayData(seur, slot="counts")
        metadata <- seur@meta.data
        pca <- Embeddings(seur[["pca"]])
        umap <- Embeddings(seur[["umap"]])
        return(list(counts=counts, metadata=metadata, pca=pca, umap=umap))
    }
    ''')
    read_seurat_r = r("read_seurat")
    seurat_data = read_seurat_r(rds_path)
    
    with localconverter(robjects.default_converter + pandas2ri.converter):
        counts = pandas2ri.rpy2py(seurat_data[0])
        metadata = pandas2ri.rpy2py(seurat_data[1])
        pca = pandas2ri.rpy2py(seurat_data[2])
        umap = pandas2ri.rpy2py(seurat_data[3])
    
    adata = ad.AnnData(X=counts.T)
    adata.obs = metadata
    adata.obsm["X_pca"] = pca
    adata.obsm["X_umap"] = umap
    
    return adata

def run_velocyto(bam_path, output_dir, gtf_path):
    cmd = f"velocyto run -b {output_dir}/barcodes.tsv -o {output_dir} -m {output_dir}/mask.gtf {bam_path} {gtf_path}"
    os.system(cmd)
    return os.path.join(output_dir, "velocyto.loom")

def main():
    adata = load_seurat(seurat_rds_path)
    
    barcodes = adata.obs_names
    np.savetxt(f"{output_dir}/barcodes.tsv", barcodes, fmt="%s")
    
    loom_path = run_velocyto(bam_file_path, output_dir, gtf_path)
    
    velo_data = scv.read(loom_path)
    
    velo_data.obs.index = [bc.split(":")[-1].replace("x", "") for bc in velo_data.obs.index]
    common_barcodes = list(set(adata.obs.index) & set(velo_data.obs.index))
    
    adata = adata[common_barcodes].copy()
    velo_data = velo_data[common_barcodes].copy()
    
    adata.layers["spliced"] = velo_data.layers["spliced"]
    adata.layers["unspliced"] = velo_data.layers["unspliced"]
    
    scv.pp.filter_and_normalize(adata, min_shared_counts=20, n_top_genes=2000)
    scv.pp.moments(adata, n_pcs=30, n_neighbors=30)
    
    scv.tl.recover_dynamics(adata)
    scv.tl.velocity(adata, mode="dynamical")
    scv.tl.velocity_graph(adata)
    
    scv.pl.velocity_embedding_stream(adata, basis="umap", color="seurat_clusters", 
                                     save=f"{output_dir}/velocity_stream.png")
    
    # PAGA analysis
    sc.tl.leiden(adata, resolution=0.8)
    sc.tl.paga(adata, groups='leiden')
    sc.pl.paga(adata, color=['leiden', 'seurat_clusters'], 
               save=f"{output_dir}/paga_graph.png")
    
    # Refine PAGA layout
    sc.tl.draw_graph(adata, init_pos='paga')
    sc.pl.draw_graph(adata, color=['leiden', 'seurat_clusters'], 
                    legend_loc='on data', save=f"{output_dir}/paga_refined.png")
    
    adata.write_h5ad(f"{output_dir}/scvelo_paga_adata.h5ad")

if __name__ == "__main__":
　　main()
　　
############
  ######
    _setQuant=set(quant)
    _map={}
    for i in range(0,len(data.iloc[0])):
        colText=data.iloc[0][i]
        if colText in _setQuant:
            _map[colText]=i
    _pepQuantMap={}
    for q in quant:
        if _map.has_key(q):
            data1=data.loc[data['pep_isunique']==1,['Unnamed: '+str(_map[q]+2)]]
            _pepQuantMap[q]=data1
    _rData['pep_ratio']=_pepQuantMap
    #######
    protein=data.groupby(level=0)
    _quantRatioMap={}
    qt=0
    for pro in protein.groups:
        group=protein.get_group(pro)
        _ratioMap={}
        flag=False
        for q in quant:
            if _map.has_key(q):
                r,p=getValueAndTTest(group['Unnamed: '+str(_map[q]+2)])
                _ratioMap[q]=[r,p]
                try:
                    if r.iloc[0]!='---':
                        flag=True
                except:
                    pass
        if flag:
            qt=qt+1
        _quantRatioMap[group.iloc[len(group)-1][0]]={'desc':group.iloc[len(group)-1][1],'sampleLevel':_ratioMap}
    fw1.write(str(len(_quantRatioMap))+'\n')
    fw1.write(str(qt)+'\n')
    fw1.close()
    _rData['prot_ratio']=_quantRatioMap
    ##############
    
    return _rData

def writePepRatio(_rData,_quant,folder):
    _map=_rData['pep_ratio']
    _num=0
    for q in _quant:
        if _map.has_key(q):
            f=open(folder+'/'+q.replace('/','-vs-')+'.pepRatio','w')
            f.write('Ratio\n')
            if _num==0:
                _num=len(_map[q][_map[q].columns[0]])
            print len(_map[q][_map[q].columns[0]])
            for r in _map[q][_map[q].columns[0]]:
                if r!='---' and r!='###' and float(r)>0 and float(r)<30:
                    f.write(str(r)+'\n')
            f.close()
    f=open(folder+'/pepRatio.expro','w')
    f.write('\t'.join(_quant)+'\n')
    for j in range(_num):
        _list=[]
        for i in range(len(_quant)):
            q=_quant[i]
            r=_map[q][_map[q].columns[0]].iloc[j]
            if r!='---' and r!='###' and float(r)>0 and float(r)<30:
                _list.append(str(r))
        if len(_list)==len(_quant):
            f.write('\t'.join(_list)+'\n')
    f.close()
def writePepSeq(_rData,folder):
    f=open(folder+'/PeptideSeq.txt','w')
    f.write('seq\tseq_length\n')
    for r in set(_rData['pep_seq']):
        try:
            f.write(str(r)+'\t'+str(len(r))+'\n')
        except:
            pass
    f.close()

def writeProtExpro(_rData,_quant,folder):
    _map=_rData['prot_ratio']
    f=open(folder+'/ProteinExprossion.txt','w')
    f.write('Protein\tProteinName')
    for q in _quant:
        f.write('\t'+q.replace('/','-vs-')+'\t'+q.replace('/','-vs-')+'-p')
    f.write('\n')
    for key in _map:
        f.write(getProteinID(key))
        _exproMap=_map[key]
        f.write('\t'+str(_exproMap['desc']))
        samples=_exproMap['sampleLevel']
        for q in _quant:
            if samples.has_key(q):
                try:
                    r=float(samples[q][0])
                    if r>=0:
                        f.write('\t'+str(r))
                    else:
                        f.write('\tNA')
                except:
                    f.write('\tNA')
                try:
                    p=float(samples[q][1])
                    if p>=0:
                        f.write('\t'+str(p))
                    else:
                        f.write('\tNA')
                except:
                    f.write('\tNA')
            else:
                f.write('\tNA\tNA')
        f.write('\n')
    f.close()
def writeMassError(_rData,folder):
    _map=_rData['mass_error']
    f=open(folder+'/MassError.txt','w')
    f.write('pep_delta\tpep_score\n')
    for i in range(len(_map['pep_delta'])):
        f.write(str(_map.iloc[i][0])+'\t'+str(_map.iloc[i][1])+'\n')
    f.close()

def getQuantNum(_quant,folder):
    data=pd.read_table(folder+'/ProteinExprossion.txt',header=0)
    _max=0
    for q in _quant:
        lev=q.replace('/','-vs-')
        #####laicl_add#######
        lev_p = lev + "-p"
        #####laicl_add#######
        try:
            os.makedirs(folder+'/'+lev)
        except:
            pass
        try:
            #up=data.loc[(data[lev]>0),['Protein']]
            #####laicl_add#######
            up=data.loc[(data[lev_p]>0),['Protein']]
            #####laicl_add#######
            if len(up)>_max:
                _max=len(up)
        except:
            pass
    return _max

def outQuantDiff(_quant,folder,fc,p):
    data=pd.read_table(folder+'/ProteinExprossion.txt',header=0)
    data.dropna(how = 'any')
    _set=set(_quant)
    for q in _quant:
        lev=q.replace('/','-vs-')
        try:
            os.makedirs(folder+'/'+lev)
        except:
            pass
        up=data.loc[(data[lev]>fc) & (data[lev+'-p']<p),['Protein']]
        down=data.loc[(data[lev]<1/fc) & (data[lev+'-p']<p),['Protein']]
        fw=open(folder+'/'+lev+'/up.txt','w')
        
        for pro in up['Protein']:
            fw.write(str(pro)+'\n')
        fw.close()
        fw=open(folder+'/'+lev+'/down.txt','w')
        for pro in down['Protein']:
            fw.write(str(pro)+'\n')
        fw.close()

        
def parseQuantDiff(_quantNames,folder,repQuant=None):
    data=pd.read_table(folder+'/ProteinExprossion.txt',header=0)
    _set=set(_quantNames)
    f=open(folder+'/diffStatistics.txt','w')
    f.write('Samples\tUP2&0.01\tDown2&0.01\tUP2&0.05\tDown2&0.05\tUP1.5&0.01\tDown1.5&0.01\tUP1.5&0.05\tDown1.5&0.05\tUP1.3&0.01\tDown1.3&0.01\tUP1.3&0.05\tDown1.3&0.05\tUP1.2&0.01\tDown1.2&0.01\tUP1.2&0.05\tDown1.2&0.05\n')
    _map={}
    data.dropna(how = 'any')
    for q in _quantNames:
        lev=q.replace('/','-vs-')
        Up1205=data.loc[(data[lev]>1.2) & (data[lev+'-p']<0.05),['Protein']]
        Dwon1205=data.loc[(data[lev]<1/1.2) & (data[lev+'-p']<0.05),['Protein']]
        Up1305=data.loc[(data[lev]>1.3) & (data[lev+'-p']<0.05),['Protein']]
        Dwon1305=data.loc[(data[lev]<1/1.3) & (data[lev+'-p']<0.05),['Protein']]
        Up1505=data.loc[(data[lev]>1.5) & (data[lev+'-p']<0.05),['Protein']]
        Dwon1505=data.loc[(data[lev]<1/1.5) & (data[lev+'-p']<0.05),['Protein']]
        Up205=data.loc[(data[lev]>2) & (data[lev+'-p']<0.05),['Protein']]  
        Dwon205=data.loc[(data[lev]<1.0/2) & (data[lev+'-p']<0.05),['Protein']]
        
        Up1201=data.loc[(data[lev]>1.2) & (data[lev+'-p']<0.01),['Protein']]
        Dwon1201=data.loc[(data[lev]<1/1.2) & (data[lev+'-p']<0.01),['Protein']]
        Up1301=data.loc[(data[lev]>1.3) & (data[lev+'-p']<0.01),['Protein']]
        Dwon1301=data.loc[(data[lev]<1/1.3) & (data[lev+'-p']<0.01),['Protein']]
        Up1501=data.loc[(data[lev]>1.5) & (data[lev+'-p']<0.01),['Protein']]
        Dwon1501=data.loc[(data[lev]<1/1.5) & (data[lev+'-p']<0.01),['Protein']]
        Up201=data.loc[(data[lev]>2) & (data[lev+'-p']<0.01),['Protein',lev]]
        Dwon201=data.loc[(data[lev]<1.0/2) & (data[lev+'-p']<0.01),['Protein']]
#         '==============================================='
#        Up121=data.loc[(data[lev]>1.2) & (data[lev+'-p']<0.1),['Protein',lev]]
#        Dwon121=data.loc[(data[lev]<1.0/1.2) & (data[lev+'-p']<0.1),['Protein']]
#         =======================================================
        if repQuant and q[0:q.find('_Rep')] in set(repQuant):
            _allSet=[Up201['Protein'],Dwon201['Protein'],Up205['Protein'],Dwon205['Protein'],Up1501['Protein'],Dwon1501['Protein']
                   ,Up1505['Protein'],Dwon1505['Protein'],Up1301['Protein'],Dwon1301['Protein'],Up1305['Protein'],Dwon1305['Protein']
                   ,Up1201['Protein'],Dwon1201['Protein'],Up1205['Protein'],Dwon1205['Protein']]
            if _map.has_key(q[0:q.find('_Rep')]):
                _map[q[0:q.find('_Rep')]].append(_allSet)
            else:
                _map[q[0:q.find('_Rep')]]=[_allSet]
        _list=[len(Up201),len(Dwon201),len(Up205),len(Dwon205),len(Up1501),len(Dwon1501)
               ,len(Up1505),len(Dwon1505),len(Up1301),len(Dwon1301),len(Up1305),len(Dwon1305)
               ,len(Up1201),len(Dwon1201),len(Up1205),len(Dwon1205)]
        f.write(lev)
        for l in _list:
            f.write('\t'+str(l))
        f.write('\n')
    if len(_map)>0:
        for key in _map:
            _line=''
            for i in range(16):
                _l1=list(_map[key][0][i])
#                 print _l1
                for _l in _map[key]:
                    _l1=getCommonList(list(_l[i]),_l1)
#                     print _l1
                _line=_line+'\t'+str(len(_l1))
            f.write(key.replace('/','-vs-')+_line+'\n')
    f.close()
    
def getAllProtein(folder):
    data=pd.read_table(folder+'/ProteinExprossion.txt',header=0)
    _list=[]
    for pro in data['Protein']:
        _list.append(extractProteinID(str(pro)))
    return _list
def getAllProtein1(folder):
    fi = open(folder+'/goblast.out','r')
    _list=[]
    for line in fi:
         _list.append(line.strip().split('\t')[1].split('|')[1])
    return _list
    fi.close()
def exchange_id(folder):
    li1 = ['MF_GOs.txt','CC_GOs.txt','BP_GOs.txt']
    dic = {}
    fi1 = open(folder+'/goblast.out','r')
    for line in fi1:
        li = line.strip().split('\t')
        dic[li[1].split('|')[1]] = li[0].split('|')[1]
    for go in li1:
        with open(folder + go,"r") as f:
            lines = f.readlines()
        with open(folder + go,"w") as f_w:
            for line in lines:
                for k in dic.keys():
                    if k in line:
                        line = line.replace(k,dic[k])
                f_w.write(line)         


def processSummary(folder,csvPath,quant):
    f=open(csvPath,'r')
    fw=open(csvPath+'.tmp.csv','w')
    fw1=open(folder+'/searchResult.stat','w')
    line=f.readline()
    flag=False
    header=None
    n=0
    u=0
    p=0
    while line:
        if line.find('Number of queries')==0:
            n=line[line.find(',')+1:len(line)-1]
        if line.find('Number of matches above homology threshold in search of real database')==0:
            p=line[line.find(',')+1:len(line)-1]
        if line.find('prot_hit_num')==0:
            flag=True
        if flag:
            if line.find(',"Quantitation summary for protein",')>0:
                fw.write(line[0:line.find(',"Quantitation summary for protein",')]+'\n')
            elif line.count(',')>32:
                if header:
                    fw.write(header+'')
                    for _ in range(line.count(',')-header.count(',')):
                        fw.write(',')
                    fw.write('\n')
                    header=None
                fw.write(line)
            elif line.find('prot_hit_num')==0:
                header=line.rstrip('\n')
            u=u+1
        line=f.readline()
    f.close()
    fw.close()
    fw1.write(str(n)+'\n')
    fw1.write(str(u-1)+'\n')
    fw1.write(str(round((u-1)*100.0/int(n),2))+'%\n')
    fw1.write(str(p)+'\n')
    fw1.close()
    print '---------Reading csv---------'
    _rData=readProteinByMascot(csvPath+'.tmp.csv',quant,1,folder)
    print '---------Read csv successful---------'
    writePepRatio(_rData, quant, folder)
    print '---------Write pepRatio successful---------'
    writePepSeq(_rData, folder)
    print '---------Write pepSeq successful---------'
    writeProtExpro(_rData, quant, folder)
    print '---------Write protein expro successful---------'
    writeMassError(_rData, folder)
    print '---------Write mass error successful---------'
    parseQuantDiff(quant,folder)
    print '---------Write protein diffstatistics successful---------'
    
def prosessCutDiff(quant, folder, fc, p,quantRep=None):
    outQuantDiff(quant, folder, fc, p)
    if quantRep:
        appendRepeat(folder, quant, quantRep)
#     fBP.write('Protein\tGO_Ids\tGO_names\tGO_levels\n')
    fCC=open(folder+'/CC_GOs.txt','w')
#     fCC.write('Protein\tGO_Ids\tGO_names\tGO_levels\n')
    fMF=open(folder+'/MF_GOs.txt','w')
#     fMF.write('Protein\tGO_Ids\tGO_names\tGO_levels\n')
    for key in allProMap:
        _gos=allProMap[key]
        bp=[]
        cc=[]
        mf=[]
        for _go in _gos:
            if _go.namespace=='biological_process':
                bp.append(_go)
            elif _go.namespace=='molecular_function':
                mf.append(_go)
            elif _go.namespace=='cellular_component':
                cc.append(_go)
        if len(bp)>0:
            fBP.write(key+'\t'+getGOLine(bp)+'\n')
        if len(cc)>0:
            fCC.write(key+'\t'+getGOLine(cc)+'\n')
        if len(mf)>0:
            fMF.write(key+'\t'+getGOLine(mf)+'\n')
    fBP.close()
    fCC.close()
    fMF.close()

def processKEGGAnnotation(folder,prot_koPath,osas):
    processKEGGAnnotationBase(folder, getAllProtein(folder), prot_koPath, osas)
    

def getKO2Protein(prot_koPath):
    f=open(prot_koPath,'r')
    lines=f.readlines()
    f.close()
    _map={}
    for line in lines:
        cols=line.rstrip().lstrip('\n').split('\t')
        if len(cols)>1 and cols[1].find('K')==0:
            _map[cols[0]]=cols[1]
    return _map
    
def processKEGGAnnotationBase(folder,_proteinlist,prot_koPath,osas):
    f=open(prot_koPath,'r')
    lines=f.readlines()
    f.close()
    _list=[]
    _set=set(_proteinlist)
    for line in lines:
#         print _set
        cols=line.rstrip().lstrip('\n').split('\t')
        if len(cols)>1 and cols[1].find('K')==0 and cols[0] in _set:
            _list.append(cols)
#     print _list
    proteinMappingPathway(_list, getKoMap(), folder+'/KEGG_Paths.txt', osas)  

def processInterDomain(folder,iprPath):
    processInterDomainBase(folder,getAllProtein(folder),iprPath)

def processInterDomainBase(folder,_list,iprPath):
    data,_max=getDataMatrix(iprPath)
    fw=open(iprPath+'.tmp','w')
    for cols in data:
        if len(cols)>=_max:
            fw.write('\t'.join(cols)+'\n')
    fw.close()
    
    data=pd.read_table(iprPath+'.tmp',header=-1,index_col=0,error_bad_lines=False)
    protein=data.groupby(level=0)
    fw=open(folder+'/Ipr_Domains.txt','w')
    _allProtein=set(_list)
    for pro in protein.groups:
#        print protein.groups
        if str(pro) in _allProtein:
#            print pro
            group=protein.get_group(pro)
            dt=group.loc[group[11]>0,[11,12]]
            iprs={}

            for i in range(len(dt[11])):
                iprs[dt.iloc[i][11]]=dt.iloc[i][12]
            txt1=''
            txt2=''
            for key in iprs:
                txt1=txt1+key+';'
                txt2=txt2+iprs[key]+';'
            fw.write(str(pro)+'\t'+txt1+'\t'+txt2+'\n')
    fw.close()
    
def getGOLine(_gos):
    ids=''
    names=''
    levels=''
    for _go in _gos:
        ids=ids+_go.id+';'
        names=names+_go.name+';'
        levels=levels+str(_go.getLevel())+';'
    return ids+'\t'+names+'\t'+levels

def processCOGAnnotition(folder,blastM8Path,kog=None):
    writeCOGClassAnnotationByKeys(getAllProtein(folder),parseM8(blastM8Path), folder+'/COG_ClassFuns.txt', kog)

def processSubCellurLocation(folder,subCellurPath,cello=None):
    processSubCellurLocationBase(folder, getAllProtein(folder), subCellurPath, cello)

def processSubCellurLocationBase(folder,_list,subCellurPath,cello=None):
    _map={}
    if cello=='cello':
        _map=parseCello(subCellurPath)
    else:
        _map=parseWorf(subCellurPath)
    _set=set(_list)
    fw=open(folder+'/SubCellur_locations.txt','w')
    for p in _map:
        if p in _set:
            fw.write(p+'\t'+_map[p]+'\n')
    fw.close()
def getDiffKey(_path):
    f=open(_path,'r')
    lines=f.readlines()
    f.close()
    _set=[]
    for line in lines:
        _set.append(line.lstrip().rstrip('\n'))
    return set(_set)

def getQKey(_path):
    f=open(_path,'r')
    lines=f.readlines()
    f.close()
    _set=[]
    for line in lines:
        _set.append(line.lstrip().rstrip('\n').split('\t')[0])
    return set(_set)

def getGOData(path):
    data=pd.read_table(path,header=-1)
    _mapIterm={}
    for i in range(len(data[0:len(data)])):
        gos=data.iloc[i][1].split(';')
        goDescs=data.iloc[i][2].split(';')
        for j in range(len(gos)):
            iterm=(gos[j]+'~'+goDescs[j].lstrip('"').rstrip('"'))
            if _mapIterm.has_key(iterm):
                _mapIterm[iterm].append(data.iloc[i][0])
            else:
                _mapIterm[iterm]=[data.iloc[i][0]]
    return {'iterms':_mapIterm,'data':data}



def outGOEnrichmentAllQ(folder,sample,stage,full=1):
    goData=getGOData(folder+'/'+stage+'_GOs.txt')
    data=goData['data']
    _mapIterm=goData['iterms']
    Q=['Q1','Q2','Q3','Q4']
    for q in Q:
        fold1=folder+'/Q/'+sample.replace('/','-vs-')
        _set=getQKey(fold1+q+'/data.txt')
        allMappingAll=0
        for pro in data[0]:
            #print pro
            if str(pro) in _set:
                allMappingAll=allMappingAll+1
        allFrame=getDataFrame(_mapIterm, _set, len(data), allMappingAll, full)
        writeCategory(allFrame.sort_values(['FisherExact']),fold1+q+'/All_GO_'+stage+'_Enrich.txt')
#         postAndSaveR(fold1+q,'All_GO_'+stage+'_Enrich')
        
def outGOEnrichmentAll(folder,_quant,stage,full=1):
    goData=getGOData(folder+'/'+stage+'_GOs.txt')
    data=goData['data']
    _mapIterm=goData['iterms']
    for q in _quant:
        fold1=folder+'/'+q.replace('/','-vs-')
        _setUP=getDiffKey(fold1+'/up.txt')
        _setDown=getDiffKey(fold1+'/down.txt')
        allMappingUp=0
        allMappingDown=0
        allMappingAll=0
        for pro in data[0]:
            if str(pro) in _setUP:
                allMappingUp=allMappingUp+1
            if str(pro) in _setDown:
                allMappingDown=allMappingDown+1
            if str(pro) in _setDown|_setUP:
                allMappingAll=allMappingAll+1
        upFrame=getDataFrame(_mapIterm, _setUP, len(data), allMappingUp, full)
        downFrame=getDataFrame(_mapIterm, _setDown, len(data), allMappingDown, full)
        allFrame=getDataFrame(_mapIterm, _setUP | _setDown, len(data), allMappingAll, full)
        writeCategory(upFrame.sort_values(['FisherExact']),fold1+'/Up_GO_'+stage+'_Enrich.txt')
        writeCategory(downFrame.sort_values(['FisherExact']),fold1+'/Down_GO_'+stage+'_Enrich.txt')
        writeCategory(allFrame.sort_values(['FisherExact']),fold1+'/All_GO_'+stage+'_Enrich.txt')

def postREVIGO(_quant,qCluster=None,sample=None):
    if _quant:
        for q in _quant:
            fold1=folder+'/'+q.replace('/','-vs-')
            for stage in ['CC','BP','MF']:
                print 'post:'+q+'-UP-'+stage
                postAndSaveR(fold1,'Up_GO_'+stage+'_Enrich')
                print 'post:'+q+'-Down-'+stage
                postAndSaveR(fold1,'Down_GO_'+stage+'_Enrich')
                print 'post:'+q+'-All-'+stage
                postAndSaveR(fold1,'All_GO_'+stage+'_Enrich')
    elif qCluster:
        Q=['Q1','Q2','Q3','Q4']
        for q in Q:
            fold1=folder+'/Q/'+sample.replace('/','-vs-')
            for stage in ['BP','CC','MF']:
                print 'post:'+q+'---'+stage
                postAndSaveR(fold1+q,'All_GO_'+stage+'_Enrich')

def outGOEnrichmentQ(folder,_quant,full=1):
    outGOEnrichmentAllQ(folder, _quant, 'BP', full)
    outGOEnrichmentAllQ(folder, _quant, 'CC', full)
    outGOEnrichmentAllQ(folder, _quant, 'MF', full)
        
def outGOEnrichment(folder,_quant,full=1):
    outGOEnrichmentAll(folder, _quant, 'BP', full)
    outGOEnrichmentAll(folder, _quant, 'CC', full)
    outGOEnrichmentAll(folder, _quant, 'MF', full)



def outKEGGEnrichmentQ(folder,sample,full=1):
    kpdt=getKEGGPathData(folder)
    _mapIterm=kpdt['iterms']
    dataLength=kpdt['Num']
    data=kpdt['data']
    fold1=folder+'/Q/'+sample.replace('/','-vs-')
    Q=['Q1','Q2','Q3','Q4']
    for q in Q:
        _set=getQKey(fold1+q+'/data.txt')
        allMappingAll=0
        _colorMap={}
        for pro in range(len(data[0])):
            if data[0].iloc[pro] in _set:
                allMappingAll=allMappingAll+1
                _colorMap[data[1].iloc[pro]]='red'
            else:
                _colorMap[data[1].iloc[pro]]='blue'
        allFrame=getDataFrame(_mapIterm, _set, dataLength, allMappingAll, full)
        writeCategory(allFrame.sort_values(['FisherExact']),fold1+q+'/All_KEGG_Enrich.txt')
        plotPathway(allFrame, _colorMap, fold1+q+'/All_Regulated')
    

def outKEGGEnrichment(folder,_quant,full=1):
    kpdt=getKEGGPathData(folder)
    _mapIterm=kpdt['iterms']
    dataLength=kpdt['Num']
    data=kpdt['data']
    for q in _quant:
        fold1=folder+'/'+q.replace('/','-vs-')
        _setUP=getDiffKey(fold1+'/up.txt')
        _setDown=getDiffKey(fold1+'/down.txt')
        allMappingUp=0
        allMappingDown=0
        allMappingAll=0
        _colorMap={}
        _kosMap={}

        for pro in range(len(data[0])):
            if str(data[0].iloc[pro]) in _setUP:
                allMappingUp=allMappingUp+1
                if _kosMap.has_key(data[1].iloc[pro]):
                    _kosMap[data[1].iloc[pro]].append('Protein:'+str(data[0].iloc[pro])+' Up-Regulated')
                else:
                    _kosMap[data[1].iloc[pro]]=['Protein:'+str(data[0].iloc[pro])+' Up-Regulated']
                if _colorMap.has_key(data[1].iloc[pro]) and (_colorMap[data[1].iloc[pro]]=='green' or _colorMap[data[1].iloc[pro]]=='yellow'):
                    _colorMap[data[1].iloc[pro]]='yellow'
                else:
                    _colorMap[data[1].iloc[pro]]='red'
            if str(data[0].iloc[pro])in _setDown:
                allMappingDown=allMappingDown+1
                if _kosMap.has_key(data[1].iloc[pro]):
                    _kosMap[data[1].iloc[pro]].append('Protein:'+str(data[0].iloc[pro])+' Down-Regulated')
                else:
                    _kosMap[data[1].iloc[pro]]=['Protein:'+str(data[0].iloc[pro])+' Down-Regulated']
                if _colorMap.has_key(data[1].iloc[pro]) and (_colorMap[data[1].iloc[pro]]=='red' or _colorMap[data[1].iloc[pro]]=='yellow'):
                    _colorMap[data[1].iloc[pro]]='yellow'
                else:
                    _colorMap[data[1].iloc[pro]]='green'
            if str(data[0].iloc[pro]) in _setDown | _setUP:
                allMappingAll=allMappingAll+1
            else:
                if _kosMap.has_key(data[1].iloc[pro]):
                    _kosMap[data[1].iloc[pro]].append('Protein:'+str(data[0].iloc[pro])+' No-Diff')
                else:
                    _kosMap[data[1].iloc[pro]]=['Protein:'+ str(data[0].iloc[pro])+' No-Diff']
                if not _colorMap.has_key(data[1].iloc[pro]):
                    _colorMap[data[1].iloc[pro]]='blue'
        upFrame=getDataFrame(_mapIterm, _setUP, dataLength, allMappingUp, full)
        downFrame=getDataFrame(_mapIterm, _setDown, dataLength, allMappingDown, full)
        allFrame=getDataFrame(_mapIterm, _setUP | _setDown, dataLength, allMappingAll, full)
        writeCategory(upFrame.sort_values(['FisherExact']),fold1+'/Up_KEGG_Enrich.txt')
        writeCategory(downFrame.sort_values(['FisherExact']),fold1+'/Down_KEGG_Enrich.txt')
        writeCategory(allFrame.sort_values(['FisherExact']),fold1+'/All_KEGG_Enrich.txt')
        plotPathway(upFrame, _colorMap, fold1+'/UP_Regulated',_kosMap)
        plotPathway(downFrame, _colorMap, fold1+'/Down_Regulated',_kosMap)
        plotPathway(allFrame, _colorMap, fold1+'/All_Regulated',_kosMap)

def getDomainData(path):
    data=pd.read_table(path,header=-1)
    _mapIterm={}
    dataLength=0
    for i in range(len(data[0:len(data)])):
        if data.iloc[i][1]>0:
            dataLength=dataLength+1
            gos=data.iloc[i][1].split(';')
            goDescs=data.iloc[i][2].split(';')
            for j in range(len(gos)):
                iterm=(gos[j]+'~'+goDescs[j].lstrip('"').rstrip('"'))
                if _mapIterm.has_key(iterm):
                    _mapIterm[iterm].append(data.iloc[i][0])
                else:
                    _mapIterm[iterm]=[data.iloc[i][0]]
    return {'iterms':_mapIterm,'Num':dataLength,'data':data}

def outDomainEnrichmentQ(folder,sample,full=1):
    domain=getDomainData(folder+'/Ipr_Domains.txt')
    data=domain['data']
    dataLength=domain['Num']
    _mapIterm=domain['iterms']
    Q=['Q1','Q2','Q3','Q4']
    for q in Q:
        fold1=folder+'/Q/'+sample.replace('/','-vs-')
        _set=getQKey(fold1+q+'/data.txt')
        allMappingAll=0
        for pro in range(len(data[0])):
            if data[0][pro] in _set:
                allMappingAll=allMappingAll+1
        allFrame=getDataFrame(_mapIterm, _set, dataLength, allMappingAll, full)
        writeCategory(allFrame.sort_values(['FisherExact']),fold1+q+'/All_Domain_Enrich.txt')

def outDomainEnrichment(folder,_quant,full=1):
    domain=getDomainData(folder+'/Ipr_Domains.txt')
    data=domain['data']
    dataLength=domain['Num']
    _mapIterm=domain['iterms']
    
    for q in _quant:
        fold1=folder+'/'+q.replace('/','-vs-')
        _setUP=getDiffKey(fold1+'/up.txt')
        _setDown=getDiffKey(fold1+'/down.txt')
        allMappingUp=0
        allMappingDown=0
        allMappingAll=0
        for pro in range(len(data[0])):
            if str(data[0][pro]) in _setUP:
                allMappingUp=allMappingUp+1
            if str(data[0][pro]) in _setDown:
                allMappingDown=allMappingDown+1
            if str(data[0][pro]) in _setDown|_setUP:
                allMappingAll=allMappingAll+1
        print allMappingUp
        upFrame=getDataFrame(_mapIterm, _setUP, dataLength, allMappingUp, full)
        downFrame=getDataFrame(_mapIterm, _setDown, dataLength, allMappingDown, full)
        allFrame=getDataFrame(_mapIterm, _setUP | _setDown, dataLength, allMappingAll, full)
        writeCategory(upFrame.sort_values(['FisherExact']),fold1+'/Up_Domain_Enrich.txt')
        writeCategory(downFrame.sort_values(['FisherExact']),fold1+'/Down_Domain_Enrich.txt')
        writeCategory(allFrame.sort_values(['FisherExact']),fold1+'/All_Domain_Enrich.txt')

def writeClassFunctionGO(folder,_quant,level=2):
    writeClassFunctionGOByStage(folder, _quant, 'BP', level)
    writeClassFunctionGOByStage(folder, _quant, 'CC', level)
    writeClassFunctionGOByStage(folder, _quant, 'MF', level)

def writeClassFunctionGOByStage(folder,_quant,stage,level=2):
    data=pd.read_table(folder+'/'+stage+'_GOs.txt',header=-1)
    _mapIterm={}
    for i in range(len(data[0:len(data)])):
        gos=data.iloc[i][1].split(';')
        goDescs=data.iloc[i][2].split(';')
        goLevels=data.iloc[i][3].split(';')
        for j in range(len(gos)):
            iterm=(gos[j]+'~'+goDescs[j])
            if goLevels[j]!='' and int(goLevels[j])==level:
                if _mapIterm.has_key(iterm):
                    _mapIterm[iterm].append(data.iloc[i][0])
                else:
                    _mapIterm[iterm]=[data.iloc[i][0]]
    for q in _quant:
        fold1=folder+'/'+q.replace('/','-vs-')
        _setUP=getDiffKey(fold1+'/up.txt')
        _setDown=getDiffKey(fold1+'/down.txt')
        outClassFuncionGO(_mapIterm, _setUP, fold1+'/Up_'+stage+'_classFun_level'+str(level)+'.txt')
        outClassFuncionGO(_mapIterm, _setDown, fold1+'/Down_'+stage+'_classFun_level'+str(level)+'.txt')
        outClassFuncionGO(_mapIterm, _setUP|_setDown, fold1+'/All_'+stage+'_classFun_level'+str(level)+'.txt')

def writeClassFunctionKEGG(folder,_quant):
    data=pd.read_table(folder+'/KEGG_Paths.txt',header=-1)
    data=data.fillna('')
    _mapIterm={}
   # _level=getKEGGLevel()
    ############laicl_add##############
    _level=getKEGGLevel(level=2)
    ############laicl_add##############
    level=None
    for i in range(len(data[0:len(data)])):
#         print data.iloc[i]
        gos=data.iloc[i][2].split(';')
        for j in range(len(gos)):
            iterm=(gos[j])
            if iterm!='':
                if _mapIterm.has_key(_level[iterm]):
                    _mapIterm[_level[iterm]].append(data.iloc[i][0])
                else:
                    _mapIterm[_level[iterm]]=[data.iloc[i][0]]
    for q in _quant:
        fold1=folder+'/'+q.replace('/','-vs-')
        _setUP=getDiffKey(fold1+'/up.txt')
        _setDown=getDiffKey(fold1+'/down.txt')
        outClassFuncionKEGG(_mapIterm, _setUP, fold1+'/Up_KEGG_classFun.txt')
        outClassFuncionKEGG(_mapIterm, _setDown, fold1+'/Down_KEGG_classFun.txt')
        outClassFuncionKEGG(_mapIterm, _setUP|_setDown, fold1+'/All_KEGG_classFun.txt')

def writeClassFunctionCOG(folder,_quant):
    data=pd.read_table(folder+'/COG_ClassFuns.txt',header=-1)
    _mapIterm={}
    for i in range(len(data[0:len(data)])):
        gos=data.iloc[i][4].split(';')
        for j in range(len(gos)):
            iterm=(gos[j])
            if iterm!='':
                if _mapIterm.has_key(iterm):
                    _mapIterm[iterm].append(data.iloc[i][0])
                else:
                    _mapIterm[iterm]=[data.iloc[i][0]]
    for q in _quant:
        fold1=folder+'/'+q.replace('/','-vs-')
        _setUP=getDiffKey(fold1+'/up.txt')
        _setDown=getDiffKey(fold1+'/down.txt')
        outClassFuncionCOG(_mapIterm, _setUP, fold1+'/Up_COG_classFun.txt')
        outClassFuncionCOG(_mapIterm, _setDown, fold1+'/Down_COG_classFun.txt')
        outClassFuncionCOG(_mapIterm, _setUP|_setDown, fold1+'/All_COG_classFun.txt')

def writeClassFunctionSubCelurLocation(folder,_quant):
    data=pd.read_table(folder+'/SubCellur_locations.txt',header=-1)
    _mapIterm={}
    for i in range(len(data[0:len(data)])):
        gos=data.iloc[i][1]
        iterm=(gos)
        if iterm!='':
            if _mapIterm.has_key(iterm):
                _mapIterm[iterm].append(data.iloc[i][0])
            else:
                _mapIterm[iterm]=[data.iloc[i][0]]
    for q in _quant:
        fold1=folder+'/'+q.replace('/','-vs-')
        _setUP=getDiffKey(fold1+'/up.txt')
        _setDown=getDiffKey(fold1+'/down.txt')
        outClassFuncionSubCelur(_mapIterm, _setUP, fold1+'/Up_SubCelur_classFun.txt')
        outClassFuncionSubCelur(_mapIterm, _setDown, fold1+'/Down_SubCelur_classFun.txt')
        outClassFuncionSubCelur(_mapIterm, _setUP|_setDown, fold1+'/All_SubCelur_classFun.txt')

def outClassFuncionSubCelur(_mapIterm,diffSet,outPath):
    f=open(outPath,'w')
    for iterm in _mapIterm:
        if iterm!='':
            upPro=[]
            for pro in set(_mapIterm[iterm]):
                if str(pro) in diffSet:
                    upPro.append(str(pro))
            if len(upPro)>0:
                f.write(iterm.rstrip().lstrip())
                f.write('\t'+str(len(upPro))+'\t'+';'.join(upPro)+'\n')
    f.close()
    
def outClassFuncionCOG(_mapIterm,diffSet,outPath):
    f=open(outPath,'w')
    for iterm in _mapIterm:
        if iterm.find('[')==0:
            upPro=[]
            for pro in set(_mapIterm[iterm]):
                if str(pro) in diffSet:
                    upPro.append(str(pro))
            if len(upPro)>0:
                f.write(iterm[1:iterm.find(']')]+'\t'+iterm[iterm.find(']')+1:len(iterm)].rstrip().lstrip())
                f.write('\t'+str(len(upPro))+'\t'+';'.join(upPro)+'\n')
    f.close()

def outClassFuncionKEGG(_mapIterm,diffSet,outPath):
    f=open(outPath,'w')
    for iterm in _mapIterm:
        if iterm.rstrip().lstrip()!='':
            upPro=[]
            for pro in set(_mapIterm[iterm]):
                if str(pro) in diffSet:
                    upPro.append(str(pro))
            if len(upPro)>0:
                f.write(iterm)
                f.write('\t'+str(len(upPro))+'\t'+';'.join(upPro)+'\n')
    f.close()
        
def outClassFuncionGO(_mapIterm,diffSet,outPath):
    f=open(outPath,'w')
    for iterm in _mapIterm:
        if iterm.find('GO')==0:
            upPro=[]
            for pro in set(_mapIterm[iterm]):
                if str(pro) in diffSet:
                    upPro.append(str(pro))
            if len(upPro)>0:
                f.write(iterm[0:iterm.find('~')]+'\t'+iterm[iterm.find('~')+1:len(iterm)])
                f.write('\t'+str(len(upPro))+'\t'+';'.join(upPro)+'\n')
    f.close()
#             pass
def getEnrichResult(path):
    f=open(path,'r')
    lines=f.readlines()
    f.close()
    _map={}
    for line in lines:
        cols=line.rstrip().lstrip('\n').split('\t')
        _map[cols[0]+'~'+cols[1]]=cols[7]
    return _map

def mergeQEnrichmentAll(folder,sample):
    mergeQEnrichment(folder, sample, 'KEGG')
    mergeQEnrichment(folder, sample, 'Domain')
    mergeQEnrichment(folder, sample, 'GO_BP')
    mergeQEnrichment(folder, sample, 'GO_CC')
    mergeQEnrichment(folder, sample, 'GO_MF')

    mergeQEnrichmentGoLeaf(folder, sample, 'GO_BP')
    mergeQEnrichmentGoLeaf(folder, sample, 'GO_CC')
    mergeQEnrichmentGoLeaf(folder, sample, 'GO_MF')
    plotCluster(folder+'/Q')
    
def mergeEnrichmentAll(folder,_quant):
    mergeEnrichment(folder, _quant, 'KEGG')    
    mergeEnrichment(folder, _quant, 'Domain')    
    mergeEnrichment(folder, _quant, 'GO_BP')
    mergeEnrichment(folder, _quant, 'GO_CC')
    mergeEnrichment(folder, _quant, 'GO_MF')

    mergeEnrichmentGoLeaf(folder, _quant, 'GO_BP')
    mergeEnrichmentGoLeaf(folder, _quant, 'GO_CC')
    mergeEnrichmentGoLeaf(folder, _quant, 'GO_MF')
    plotCluster(folder+'/Cluster')

def mergeQEnrichmentGoLeaf(folder,sample,stage,pValue=0.05):
    q1=getEnrichResult(folder+'/Q/'+sample.replace('/','-vs-')+'Q1/All_'+stage+'_Enrich.txt.tmp')
    q2=getEnrichResult(folder+'/Q/'+sample.replace('/','-vs-')+'Q2/All_'+stage+'_Enrich.txt.tmp')
    q3=getEnrichResult(folder+'/Q/'+sample.replace('/','-vs-')+'Q3/All_'+stage+'_Enrich.txt.tmp')
    q4=getEnrichResult(folder+'/Q/'+sample.replace('/','-vs-')+'Q4/All_'+stage+'_Enrich.txt.tmp')
    keys=[]
    for key in q1:
        keys.append(key)
    for key in q2:
        keys.append(key)
    for key in q3:
        keys.append(key)
    for key in q4:
        keys.append(key)
    fw=open(folder+'/Q/'+stage+'_Leaf_Enrich.txt','w')
    fw.write('Category_ID\tCategory_Name\tQ1\tQ2\tQ3\tQ4\n')
    _mapLine={}
    _goIds=[]
    for key in set(keys):
        line=''
        flag=False
        if q1.has_key(key):
            line=line+'\t'+q1[key]
            if float(q1[key])<pValue:
                flag=True
        else:
            line=line+'\t1'
        if q2.has_key(key):
            line=line+'\t'+q2[key]
            if float(q2[key])<pValue:
                flag=True    
        else:
            line=line+'\t1'
        if q3.has_key(key):
            if float(q3[key])<pValue:
                flag=True
            line=line+'\t'+q3[key]
        else:
            line=line+'\t1'
        if q4.has_key(key):
            if float(q4[key])<pValue:
                flag=True
            line=line+'\t'+q4[key]
        else:
            line=line+'\t1'
        if flag:
            _mapLine[key[0:key.find('~')]]=key[0:key.find('~')]+'\t'+key[key.find('~')+1:len(key)]+line+'\n'
            _goIds.append(key[0:key.find('~')])
    
    for goid in getLeafs(set(_goIds)):
        fw.write(_mapLine[goid])
    fw.close()

def mergeEnrichmentGoLeaf(folder,_quant,stage,pValue=0.05):
    _list=[]
    keys=[]
    for q in _quant:
        sample=q.replace('/','-vs-')    
        q1=getEnrichResult(folder+'/'+sample+'/All_'+stage+'_Enrich.txt.tmp')
        _list.append(q1)
        for key in q1:
            keys.append(key)
    try:
        os.mkdir(folder+'/Cluster')
    except:
        pass
    fw=open(folder+'/Cluster/'+stage+'_Leaf_Enrich.txt','w')
    fw.write('Category_ID\tCategory_Name')
    for q in _quant:
        sample=q.replace('/','-vs-')    
        fw.write('\t'+sample)
    fw.write('\n')
    
    _mapLine={}
    _goIds=[]
    for key in set(keys):
        line=''
        flag=False
        for q1 in _list:
            if q1.has_key(key):
                line=line+'\t'+q1[key]
                if float(q1[key])<pValue:
                    flag=True
            else:
                line=line+'\t1'
        if flag:
            _mapLine[key[0:key.find('~')]]=key[0:key.find('~')]+'\t'+key[key.find('~')+1:len(key)]+line+'\n'
            _goIds.append(key[0:key.find('~')])
    for goid in getLeafs(set(_goIds)):
        fw.write(_mapLine[goid])
    fw.close()

def mergeEnrichment(folder,_quant,stage,pValue=0.05):
    #if(len(_quant)>2):
    #######laicl_add########
    if(len(_quant)>=2):
    #######laicl_add########
        _listUp=[]
        _listDown=[]
        _listAll=[]
        keysUp=[]
        keysDown=[]
        keysAll=[]
        header=''
        for q in _quant:
            sample=q.replace('/','-vs-')
            header=header+'\t'+sample    
            createKeysAndList(folder+'/'+sample+'/All_'+stage+'_Enrich.txt.tmp',_listAll,keysAll)
            createKeysAndList(folder+'/'+sample+'/Up_'+stage+'_Enrich.txt.tmp',_listUp,keysUp)
            createKeysAndList(folder+'/'+sample+'/Down_'+stage+'_Enrich.txt.tmp',_listDown,keysDown)
            
        try:
            os.mkdir(folder+'/Cluster')
            os.mkdir(folder+'/Cluster/Up')
            os.mkdir(folder+'/Cluster/All')
            os.mkdir(folder+'/Cluster/Down')
        except:
            pass
        outClusterByFileList(folder+'/Cluster/All/'+stage+'_Enrich.txt', header, pValue, _listAll, keysAll)
        outClusterByFileList(folder+'/Cluster/Up/'+stage+'_Enrich.txt', header, pValue, _listUp, keysUp)
        outClusterByFileList(folder+'/Cluster/Down/'+stage+'_Enrich.txt', header, pValue, _listDown, keysDown)
    else:        
        _list=[]
        _keys=[]
        header=''
        for q in _quant:
            sample=q.replace('/','-vs-')
            createKeysAndList(folder+'/'+sample+'/All_'+stage+'_Enrich.txt.tmp',_list,_keys)
            header=header+'\t'+sample+'_All'
        for q in _quant:
            sample=q.replace('/','-vs-')
            createKeysAndList(folder+'/'+sample+'/Up_'+stage+'_Enrich.txt.tmp',_list,_keys)
            header=header+'\t'+sample+'_Up'
        for q in _quant:
            sample=q.replace('/','-vs-')
            createKeysAndList(folder+'/'+sample+'/Down_'+stage+'_Enrich.txt.tmp',_list,_keys)
            header=header+'\t'+sample+'_Down'
        try:
            os.mkdir(folder+'/Cluster')            
        except:
            pass            
        outClusterByFileList(folder+'/Cluster/'+stage+'_Enrich.txt', header, pValue, _list, _keys)
        
    
def createKeysAndList(_path,_list,_keys):
    q1=getEnrichResult(_path)
    _list.append(q1)
    for key in q1:
        _keys.append(key)
    

def outClusterByFileList(outPath,header,pValue,_list,keys):
    fw=open(outPath,'w')
    fw.write('Category_ID\tCategory_Name')
    fw.write(header+'\n')
    for key in set(keys):
        line=''
        flag=False
        for q1 in _list:
            if q1.has_key(key):
                line=line+'\t'+q1[key]
                if float(q1[key])<pValue:
                    flag=True
            else:
                line=line+'\t1'
        if flag:
            fw.write(key[0:key.find('~')]+'\t'+key[key.find('~')+1:len(key)]+line+'\n')
    fw.close()
        
    
    
def mergeQEnrichment(folder,sample,stage,pValue=0.05):
    q1=getEnrichResult(folder+'/Q/'+sample.replace('/','-vs-')+'Q1/All_'+stage+'_Enrich.txt.tmp')
    q2=getEnrichResult(folder+'/Q/'+sample.replace('/','-vs-')+'Q2/All_'+stage+'_Enrich.txt.tmp')
    q3=getEnrichResult(folder+'/Q/'+sample.replace('/','-vs-')+'Q3/All_'+stage+'_Enrich.txt.tmp')
    q4=getEnrichResult(folder+'/Q/'+sample.replace('/','-vs-')+'Q4/All_'+stage+'_Enrich.txt.tmp')
    keys=[]
    for key in q1:
        keys.append(key)
    for key in q2:
        keys.append(key)
    for key in q3:
        keys.append(key)
    for key in q4:
        keys.append(key)
    fw=open(folder+'/Q/'+stage+'_Enrich.txt','w')
    fw.write('Category_ID\tCategory_Name\tQ1\tQ2\tQ3\tQ4\n')
    for key in set(keys):
        line=''
        flag=False
        if q1.has_key(key):
            line=line+'\t'+q1[key]
            if float(q1[key])<pValue:
                flag=True
        else:
            line=line+'\t1'
        if q2.has_key(key):
            line=line+'\t'+q2[key]
            if float(q2[key])<pValue:
                flag=True    
        else:
            line=line+'\t1'
        if q3.has_key(key):
            if float(q3[key])<pValue:
                flag=True
            line=line+'\t'+q3[key]
        else:
            line=line+'\t1'
        if q4.has_key(key):
            if float(q4[key])<pValue:
                flag=True
            line=line+'\t'+q4[key]
        else:
            line=line+'\t1'
        if flag:
            fw.write(key[0:key.find('~')]+'\t'+key[key.find('~')+1:len(key)]+line+'\n')
    fw.close()
##############Report#################
def getAnnotationMap(_path):
    f=open(_path,'r')
    lines=f.readlines()
    f.close()
    _map={}
    for line in lines:
        cols=line.rstrip().lstrip('\n').split('\t')
        if len(cols)>1 and cols[1].rstrip().lstrip()!='':
            _map[cols[0]]=cols[1:len(cols)]
    return _map
        
def mergeAnnotation(folder,outPath):
    _mapGO_BP=getAnnotationMap(folder+'/BP_GOs.txt')
    _mapGO_CC=getAnnotationMap(folder+'/CC_GOs.txt')
    _mapGO_MF=getAnnotationMap(folder+'/MF_GOs.txt')
    _mapDomain=getAnnotationMap(folder+'/Ipr_Domains.txt')
    _mapKEGG=getAnnotationMap(folder+'/KEGG_Paths.txt')
    #_mapSubcelur=getAnnotationMap(folder+'/SubCellur_loactions.txt')
    _mapSubcelur=getAnnotationMap(folder+'/SubCellur_locations.txt')
    _mapCOG=getAnnotationMap(folder+'/COG_ClassFuns.txt')
    f=open(folder+'/ProteinExprossion.txt','r')
    fw=open(outPath,'w')
    line=f.readline()
    fw.write(line.rstrip().lstrip('\n'))
    fw.write('\tBP_GO_ID\tBP_GO_Desc\tBP_GO_Level')
    fw.write('\tCC_GO_ID\tCC_GO_Desc\tCC_GO_Level')
    fw.write('\tMF_GO_ID\tMF_GO_Desc\tMF_GO_Level')
    fw.write('\tKEGG_KO\tKEGG_Pathway_ID\tKEGG_Pathway_Desc')
    fw.write('\tDomain_ID\tDomain_Desc')
    fw.write('\tSubcellurLocation')
    fw.write('\tCOG_Gene\tBlastScore\tCOG_Code\tCOG_Desc\n')
    
    line=f.readline()
    while line:
        line=line.rstrip().lstrip('\n')
        cols=line.split('\t')
        fw.write(line)
        if _mapGO_BP.has_key(cols[0]):
            fw.write('\t'+'\t'.join(_mapGO_BP[cols[0]]))
        else:
            fw.write('\t\t\t')
        if _mapGO_CC.has_key(cols[0]):
            fw.write('\t'+'\t'.join(_mapGO_CC[cols[0]]))
        else:
            fw.write('\t\t\t')
        if _mapGO_MF.has_key(cols[0]):
            fw.write('\t'+'\t'.join(_mapGO_MF[cols[0]]))
        else:
            fw.write('\t\t\t')
        if _mapKEGG.has_key(cols[0]):
            fw.write('\t'+'\t'.join(_mapKEGG[cols[0]]))
            if len(_mapKEGG[cols[0]])<3:
                fw.write('\t\t')
        else:
            fw.write('\t\t\t')
        if _mapDomain.has_key(cols[0]):
            fw.write('\t'+'\t'.join(_mapDomain[cols[0]]))
        else:
            fw.write('\t\t')
        if _mapSubcelur.has_key(cols[0]):
            fw.write('\t'+'\t'.join(_mapSubcelur[cols[0]]))
        else:
            fw.write('\t')
        if _mapCOG.has_key(cols[0]):
            fw.write('\t'+'\t'.join(_mapCOG[cols[0]])+'\n')
        else:
            fw.write('\t\t\t\t\n')
        line=f.readline()
    f.close()
    fw.close()
    
def convertDiffAnnotationXls(folder,sample,annotPath,outFolder):
    upSet=getDiffKey(folder+'/'+sample+'/up.txt')
    downSet=getDiffKey(folder+'/'+sample+'/down.txt')
    f=open(annotPath,'r')
    line=f.readline()
    cols=line.rstrip().lstrip('\n').split('\t')
    fw=open(outFolder+'/RegulatedAnnotation.xls','w')
    fw.write('\t'.join(cols[0:2])+'\tRegulated-Stage\t'+'\t'.join(cols[2:len(cols)])+'\n')
    line=f.readline()
    while line:
        cols=line.rstrip().lstrip('\n').split('\t')
        if cols[0] in upSet:
            fw.write('\t'.join(cols[0:2])+'\tUp\t'+'\t'.join(cols[2:len(cols)])+'\n')
        elif cols[0] in downSet:
            fw.write('\t'.join(cols[0:2])+'\tDown\t'+'\t'.join(cols[2:len(cols)])+'\n')
        line=f.readline()
    f.close()
    fw.close()

def convertClassfunction(_path,header,outPath):
    f=open(_path,'r')
    fw=open(outPath,'w')
    fw.write(header+'\n')
    line=f.readline()
    while line:
        fw.write(line)
        line=f.readline()
    f.close()
    fw.close()
#     tableToJson(_path, outPath+'.json', len(header.split('\t')))
    
def convertEnrichment(_path,outPath):
    f=open(_path,'r')
    fw=open(outPath,'w')
    fw.write("Category_ID\tCategory_Name\tDiffmapping\tProteinMapping\tDiffNum\tProteinNum\tFoldEnrichment\tFisher's exact test p value\tMapping ProteinIDs\n")
    line=f.readline()
    while line:
        fw.write(line)
        line=f.readline()
    f.close()
    fw.close()
#     tableToJson(_path, outPath+'.json', 9)


def copyTopGO(folder1,folder2):
    for f in os.listdir(folder1):
        fName=f
        if fName.find('topGO')>0 and (fName.find('.jpg') or fName.find('.pdf')):
            if fName.find('up')>-1:
                copyFile(folder1+'/'+f, folder2+'/Up_Regulated'+fName[fName.find('_'):fName.find('_topGO')]+'_View'+fName[fName.find('.'):len(fName)])
            elif fName.find('down')>-1:
                copyFile(folder1+'/'+f, folder2+'/Down_Regulated'+fName[fName.find('_'):fName.find('_topGO')]+'_View'+fName[fName.find('.'):len(fName)])
            elif fName.find('all')>-1:
                copyFile(folder1+'/'+f, folder2+'/All_Regulated'+fName[fName.find('_'):fName.find('_topGO')]+'_View'+fName[fName.find('.'):len(fName)])

def formatReport(folder,_quant,rep=None,net=None,iPath=None):
    try:
        os.makedirs(folder+'/Report/Data/Cluster')
        os.makedirs(folder+'/Report/Data/Summary')
    except:
        pass
    mergeAnnotation(folder, folder+'/Report/Data/CombineAnnotation.xls')
#     annotationtoJsonAll(folder, folder+'/Report/Data')
    if os.path.exists(folder+'/QualityControl_MassError'):
        copyImage(folder+'/QualityControl_MassError', folder+'/Report/Data/Summary/QualityControl_MassError')
        copyImage(folder+'/QualityControl_PepDistribution', folder+'/Report/Data/Summary/QualityControl_PepDistribution')
    else:
        for f in os.listdir(folder):
            if f.find('QualityControl_MassError')==0 and f.find('.pdf')>0:
                copyImage(folder+'/'+f[0:f.find('.pdf')], folder+'/Report/Data/Summary/'+f[0:f.find('.pdf')])
            if f.find('QualityControl_PepDistribution')==0 and f.find('.pdf')>0:
                copyImage(folder+'/'+f[0:f.find('.pdf')], folder+'/Report/Data/Summary/'+f[0:f.find('.pdf')])
            if f.find('_RatioDistrubition')>0 and f.find('_Rep')>0 and f.find('.pdf')>0:
                copyImage(folder+'/'+f[0:f.find('.pdf')], folder+'/Report/Data/Summary/'+f[0:f.find('.pdf')])
                
        
    _mapAll=[]

    for q in _quant:
        sample=q.replace('/','-vs-')
        if rep:
            for m in rep:
                mm =m
                copyImage(folder+'/'+sample+'_RatioDistrubition_'+mm, folder+'/Report/Data/Summary/'+sample+'_RatioDistrubition_'+mm)
        else:
            copyImage(folder+'/'+sample+'_RatioDistrubition', folder+'/Report/Data/Summary/'+sample+'_RatioDistrubition')
    
        
    for q in _quant:
        sample=q.replace('/','-vs-')
        #copyImage(folder+'/'+sample+'_RatioDistrubition', folder+'/Report/Data/Summary/'+sample+'_RatioDistrubition')
        copyImage(folder+'/'+sample+'_ProteinRatioVocano', folder+'/Report/Data/Summary/'+sample+'_ProteinRatioVocano')
        
        fold1=folder+'/Report/Data/'+sample
        fold2=folder+'/'+sample
        try:
            os.makedirs(fold1)
            os.makedirs(fold1+'/Functional_Classification')
            os.makedirs(fold1+'/Functional_Enrichment')
        except:
            pass
        _map={}
        convertDiffAnnotationXls(folder, sample, fold1+'/../CombineAnnotation.xls', fold1)
        convertClassfunction(fold2+"/All_BP_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/All_Regulated_BP_Level2.xls')
        convertClassfunction(fold2+"/All_CC_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/All_Regulated_CC_Level2.xls')
        convertClassfunction(fold2+"/All_MF_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/All_Regulated_MF_Level2.xls')
        copyImage(fold2+'/All_GO_Level2_Classfun', fold1+'/Functional_Classification/All_Regulated_Level2')
        copyImage(fold2+'/All_GO_Level2_Classfun_tm', fold1+'/Functional_Classification/All_Regulated_Level2_tm')
        
        convertClassfunction(fold2+"/Up_BP_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Up_Regulated_BP_Level2.xls')
        convertClassfunction(fold2+"/Up_CC_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Up_Regulated_CC_Level2.xls')
        convertClassfunction(fold2+"/Up_MF_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Up_Regulated_MF_Level2.xls')
        copyImage(fold2+'/Up_GO_Level2_Classfun', fold1+'/Functional_Classification/Up_Regulated_Level2')
        copyImage(fold2+'/Up_GO_Level2_Classfun_tm', fold1+'/Functional_Classification/Up_Regulated_Level2_tm')
        convertClassfunction(fold2+"/Down_BP_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Down_Regulated_BP_Level2.xls')
        convertClassfunction(fold2+"/Down_CC_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Down_Regulated_CC_Level2.xls')
        convertClassfunction(fold2+"/Down_MF_classFun_level2.txt",'GO_ID\tGO_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Down_Regulated_MF_Level2.xls')
        copyImage(fold2+'/Down_GO_Level2_Classfun', fold1+'/Functional_Classification/Down_Regulated_Level2')
        copyImage(fold2+'/Down_GO_Level2_Classfun_tm', fold1+'/Functional_Classification/Down_Regulated_Level2_tm')
            
        convertClassfunction(fold2+"/Up_COG_classFun.txt",'COG_CODE\tCOG_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Up_Regulated_COG.xls')
        convertClassfunction(fold2+"/All_COG_classFun.txt",'COG_CODE\tCOG_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/All_Regulated_COG.xls')
        convertClassfunction(fold2+"/Down_COG_classFun.txt",'COG_CODE\tCOG_Name\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Down_Regulated_COG.xls')
        copyImage(fold2+'/All_COG_Classfun', fold1+'/Functional_Classification/All_Regulated_COG')
        copyImage(fold2+'/Up_COG_Classfun', fold1+'/Functional_Classification/Up_Regulated_COG')
        copyImage(fold2+'/Down_COG_Classfun', fold1+'/Functional_Classification/Down_Regulated_COG')
        
        convertClassfunction(fold2+"/Up_SubCelur_classFun.txt",'SubCellularLocation\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Up_Regulated_SubCellularLocation.xls')
        convertClassfunction(fold2+"/All_SubCelur_classFun.txt",'SubCellularLocation\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/All_Regulated_SubCellularLocation.xls')
        convertClassfunction(fold2+"/Down_SubCelur_classFun.txt",'SubCellularLocation\tNo. of Proteins\tProteinIDs',fold1+'/Functional_Classification/Down_Regulated_SubCellularLocation.xls')
        copyImage(fold2+'/All_Subcelur_Classfun', fold1+'/Functional_Classification/All_Regulated_SubCellularLocation')
        copyImage(fold2+'/Up_Subcelur_Classfun', fold1+'/Functional_Classification/Up_Regulated_SubCellularLocation')
        copyImage(fold2+'/Down_Subcelur_Classfun', fold1+'/Functional_Classification/Down_Regulated_SubCellularLocation')

        stages=['All_Domain','Up_Domain','Down_Domain',
               'All_KEGG','Up_KEGG','Down_KEGG',
               'All_GO_MF','Up_GO_MF','Down_GO_MF',
               'All_GO_CC','Up_GO_CC','Down_GO_CC',
               'All_GO_BP','Up_GO_BP','Down_GO_BP',]
        for stage in stages:
            convertEnrichment(fold2+'/'+stage+'_Enrich.txt', fold1+'/Functional_Enrichment/'+stage[0:stage.find('_')]+'_Regulated'+stage[stage.find('_'):len(stage)]+'_Enrich.xls')
            copyImage(fold2+'/'+stage+'_Enrich',fold1+'/Functional_Enrichment/'+stage[0:stage.find('_')]+'_Regulated'+stage[stage.find('_'):len(stage)]+'_Enrich')
            try:
                copyImage(fold2+'/'+stage+'_Enrich_Scatter',fold1+'/Functional_Enrichment/'+stage[0:stage.find('_')]+'_Regulated'+stage[stage.find('_'):len(stage)]+'_Enrich_Scatter')
                copyImage(fold2+'/'+stage+'_Enrich_Treemap',fold1+'/Functional_Enrichment/'+stage[0:stage.find('_')]+'_Regulated'+stage[stage.find('_'):len(stage)]+'_Enrich_Treemap')
            except:
                pass
        copyFolder(fold2+'/All_Regulated', fold1+'/Functional_Enrichment/KEGG_IMG_All_Regulated')
        copyFolder(fold2+'/Down_Regulated', fold1+'/Functional_Enrichment/KEGG_IMG_Down_Regulated')
        copyFolder(fold2+'/UP_Regulated', fold1+'/Functional_Enrichment/KEGG_IMG_Up_Regulated')
        copyTopGO(fold2, fold1+'/Functional_Enrichment')
    formatCluster(folder)
    if rep:
        try:
            os.makedirs(folder+'/Report/Data/Repeatability')
        except:
            pass
        copyImage(folder+'/Repeatability/Repeatability', folder+'/Report/Data/Repeatability/Repeatability')
    '''
    if net and len(net)>0:
        for q in net:
            try:
                os.makedirs(folder+'/Report/Data/Network/'+q.replace('/','-vs-'))
            except:
                pass
            for f in os.listdir(folder+'/Network/'+q.replace('/','-vs-')):
                 copyFolder(folder+'/Network/'+q.replace('/','-vs-')+'/'+f, folder+'/Report/Data/Network/'+q.replace('/','-vs-')+'/'+f)
                 copyFile(folder+'/Network/'+q.replace('/','-vs-')+'/'+f, folder+'/Report/Data/Network/'+q.replace('/','-vs-')+'/'+f)
    
    if iPath:
        try:
            os.makedirs(folder+'/Report/Data/iPath')
        except:
            pass
        for f in os.listdir(folder+'/iPath2'):
            if os.path.exists(folder+'/iPath2/'+f+'/Metabolic.svg') and (not os.path.exists(folder+'/iPath2/'+f+'/Metabolic.jpg') or not os.path.exists(folder+'/iPath2/'+f+'/Regulatory.jpg')):
                drawing = svg2rlg(folder+'/iPath2/'+f+'/Metabolic.svg')
                renderPDF.drawToFile(drawing, folder+'/iPath2/'+f+'/Metabolic.pdf')
                renderPM.drawToFile(drawing, folder+'/iPath2/'+f+'/Metabolic.jpg','JPG')
                
                drawing = svg2rlg(folder+'/iPath2/'+f+'/Biosynthesis.svg')
                renderPDF.drawToFile(drawing, folder+'/iPath2/'+f+'/Biosynthesis.pdf')
                renderPM.drawToFile(drawing, folder+'/iPath2/'+f+'/Biosynthesis.jpg','JPG')
                
                drawing = svg2rlg(folder+'/iPath2/'+f+'/Regulatory.svg')
                renderPDF.drawToFile(drawing, folder+'/iPath2/'+f+'/Regulatory.pdf')
                renderPM.drawToFile(drawing, folder+'/iPath2/'+f+'/Regulatory.jpg','JPG')    
                            
            copyFolder(folder+'/iPath2/'+f, folder+'/Report/Data/iPath/'+f)
            copyFile(folder+'/iPath2/'+f, folder+'/Report/Data/iPath/'+f)
    '''
def copyCluster(path,outPath):
    for uad in ['Up','Down','All']:
        for f in os.listdir(path+'/'+uad):
            try:
                os.makedirs(folder+'/Report/Data/'+outPath+'/'+uad)
            except:
                pass
            if f.find('.pdf')>0:
                copyImage(path+'/'+uad+'/'+f[0:f.find('.pdf')],folder+'/Report/Data/'+outPath+'/'+uad+'/'+f[0:f.find('.pdf')])
            
def formatCluster(folder):
    if os.path.exists(folder+'/Cluster'):
        if os.path.exists(folder+'/Cluster/Up'):
            copyCluster(folder+'/Cluster', 'Cluster')
        else:
            for f in os.listdir(folder+'/Cluster'):
                if f.find('.pdf')>0:
                    copyImage(folder+'/Cluster/'+f[0:f.find('.pdf')],folder+'/Report/Data/Cluster/'+f[0:f.find('.pdf')])
                if f.find('Cluster_')==0 and not os.path.isfile(folder+'/Cluster/'+f):
                    if os.path.exists(folder+'/Cluster/'+f+'/Up'):
                        copyCluster(folder+'/Cluster/'+f, 'Cluster/'+f)
                    else:
                        for ff in os.listdir(folder+'/Cluster/'+f):
                            if ff.find('.pdf')>0:
                                copyImage(folder+'/Cluster/'+ff[0:ff.find('.pdf')],folder+'/Report/Data/Cluster/'+ff[0:ff.find('.pdf')])
    else:
        sample=''
        Q=['Q1','Q2','Q3','Q4']
        for f in os.listdir(folder+'/Q'):
            if f.find('.pdf')>0:
                copyImage(folder+'/Q/'+f[0:f.find('.pdf')],folder+'/Report/Data/Cluster/'+f[0:f.find('.pdf')])
            elif os.path.isdir(folder+'/Q/'+f):
                sample= f[0:-2]
        stages=['All_Domain','All_KEGG','All_GO_MF','All_GO_CC','All_GO_BP',]
        for q in Q:
            fold2=folder+'/Q/'+sample+q
            fold1=folder+'/Report/Data/Cluster/'+q+'_'+sample
            try:
                os.makedirs(fold1)
            except:
                pass
            for stage in stages:
                convertEnrichment(fold2+'/'+stage+'_Enrich.txt', fold1+'/'+stage[0:stage.find('_')]+'_Regulated'+stage[stage.find('_'):len(stage)]+'_Enrich.xls')
            copyFolder(fold2+'/All_Regulated', fold1+'/KEGG_IMG_All_Regulated')
        pass
        
    
def tableToJson(_path,outPath,length):
    f=open(_path,'r')
    line=f.readline()
    _list=[]
    while line:
        cols=line.rstrip().lstrip('\n').split('\t')
        _map={}
        for i in range(length):
            if i<len(cols):
                _map['V'+str(i)]=cols[i]
            else:
                _map['V'+str(i)]=''
        _list.append(_map)
        line=f.readline()
    f.close()
    fw=open(outPath,'w')
    fw.write(json.dumps(_list))
    fw.close()

def annotationtoHtml(_path,proteinSet,length):
    f=open(_path,'r')
    line=f.readline()
    _list=[]
    while line:
        cols=line.rstrip().lstrip('\n').split('\t')
        
        if cols[0] in proteinSet:
            _map={}
            for i in range(length):
                if i<len(cols):
                    _map['V'+str(i)]=cols[i]
                else:
                    _map['V'+str(i)]=''
            
            _list.append(_map)
        line=f.readline()
    f.close()
    
    return _list
def annotationtoJson(_path,proteinSet,outPath,length):
    fw=open(outPath,'w')
    fw.write(json.dumps(annotationtoHtml(_path, proteinSet, length)))
    fw.close()
def annotationtoJsonAll(folder,outFolder):
    _set=set(getAllProtein(folder))
    annotationtoJson(folder+'/BP_GOs.txt', _set, outFolder+'/BP_GOs.json', 4)
    annotationtoJson(folder+'/CC_GOs.txt', _set, outFolder+'/CC_GOs.json', 4)
    annotationtoJson(folder+'/MF_GOs.txt', _set, outFolder+'/MF_GOs.json', 4)
    annotationtoJson(folder+'/KEGG_Paths.txt', _set, outFolder+'/KEGG_Paths.json', 4)
    annotationtoJson(folder+'/Ipr_Domains.txt', _set, outFolder+'/Ipr_Domains.json', 3)
    annotationtoJson(folder+'/COG_ClassFuns.txt', _set, outFolder+'/COG_ClassFuns.json', 5)
    annotationtoJson(folder+'/SubCellur_locations.txt', _set, outFolder+'/SubCellur_locations.json', 2)
    
#     data=pd.read_table(_path,header=0)
#     json=data.to_json()
#     print json


def writeSampleInfo(folder,_quant,_samplePath):
    line='<div class="col-xs-12 col-sm-12"><div class="blog-header">'
    line=line+'<h1 class="blog-title">Project Report</h1>'
    line=line+'<p class="lead blog-description">Mhelix Proteomics Quantification Project Report</p>'
    line=line+'</div>'
    line=line+'<h2 class="blog-post-title lead" id="Summary">Summary</h2>'
    line=line+'<p class="blog-description" style="margin-bottom: 0px;">Sample Information:</p>'
    line=line+'<table class="table table-bordered"><thead><tr><th>SampleName</th><th>Sample Name Alias</th><th>Marked Name</th></tr></thead><tbody>'
    f=open(_samplePath,'r')
    #f.readline()
    lines=f.readlines()
    f.close()
    for l in lines:
        cols=l.rstrip().lstrip('\n').split('\t')
        line=line+'<tr><td>'+cols[0]+'</td><td>'+cols[1]+'</td><td>'+cols[2]+'</td></tr>\n'
    line=line+'<tr><td>Identify Protein Num</td><td colspan="2">'+str(len(getAllProtein(folder)))+'</td></tr>\n'
    line=line+'<tr><td>Quantify Protein Num</td><td colspan="2">'+str(getQuantNum(_quant, folder))+'</td></tr>\n'
    line=line+'</tbody></table>\n'
    return line

def writeDiffStatistics(folder,_quant,ind='2&0.01'):
    line='<p class="blog-description" style="margin-bottom: 0px;"> Protein Quantification Statistics Sheet:</p>\n'
    line=line+'<table class="table table-bordered table-condensed" style="text-align: center"><thead>'
    line=line+'<tr style="text-align: center">'
    line1=''
    line2=''
    prex=['2&0.01','2&0.05','1.5&0.01','1.5&0.05','1.3&0.01','1.3&0.05','1.2&0.01','1.2&0.05']
    for p in prex:
        if ind==p:
            line1=line1+'<th colspan="2" class="bg-success" style="text-align: center">'+p+'</th>'
            line2=line2+'<th class="bg-success">Up</th><th class="bg-success">Down</th>'
        else:
            line1=line1+'<th colspan="2" style="text-align: center">'+p+'</th>'
            line2=line2+'<th>Up</th><th>Down</th>'
    line=line+'<th rowspan="2">Group</th>'+line1
    line=line+'</tr><tr style="text-align: center">'+line2
    line=line+'</tr></thead><tbody>'
    f=open(folder+'/diffStatistics.txt','r')
    f.readline()
    lines=f.readlines()
    f.close()
    for l in lines:
        cols=l.rstrip().lstrip('\n').split('\t')
        cols[0]=cols[0].replace('-vs-','/')
        if cols[0] in set(_quant):
            line=line+'<tr>'
            for col in range(len(cols)):
                line=line+'<td'
                if col>0 and prex[(col-1)/2]==ind:
                    line=line+' class="bg-success"'
                line=line+'>'+cols[col]+'</td>'
            line=line+'</tr>\n'
    line=line+'</tbody></table></div>'
    return line

def writeSummaryImagsCommon(folder,addImges):
    line='<div class="col-xs-6">'
    line=line+'<p class="blog-description" style="margin-bottom: 0px;"> Quality Control:</p>'
    line=line+'<div id="carousel-example-generic" class="carousel slide" data-ride="carousel">'
    line=line+'<!-- Indicators -->'
    line=line+'<ol class="carousel-indicators">'
    line=line+'<li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>'
    line=line+'<li data-target="#carousel-example-generic" data-slide-to="1"></li>'
#     for q in range(2*len(_quant)):
#         line=line+'<li data-target="#carousel-example-generic" data-slide-to="'+str(q+2)+'"></li>'
    line=line+'</ol>'
    line=line+'<!-- Wrapper for slides -->'
    line=line+'<div class="carousel-inner" role="listbox">'
    if folder:
        active=''
        for f in os.listdir(folder+'/Report/Data/Summary'):
            if f.find('QualityControl_MassError')==0 and f.find('.jpg')>0:
                if active=='':
                    active='active'
                    line=line+'<div class="item active">'
                else:
                    line=line+'<div class="item">'
                line=line+'<img src="Data/Summary/'+f+'" alt="..."'
                line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Summary/'+f+'" data-label=""></div>'
            if f.find('QualityControl_PepDistribution')==0 and f.find('.jpg')>0:
                line=line+'<div class="item">'
                line=line+'<img src="Data/Summary/'+f+'" alt="..."'
                line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Summary/'+f+'" data-label=""></div>'
    else:
        line=line+'<div class="item active">'
        line=line+'<img src="Data/Summary/QualityControl_MassError.jpg" alt="..."'
        line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Summary/QualityControl_MassError.jpg" data-label=""></div>'
        
        line=line+'<div class="item">'
        line=line+'<img src="Data/Summary/QualityControl_PepDistribution.jpg" alt="..."'
        line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Summary/QualityControl_PepDistribution.jpg" data-label=""></div>'
    
    if addImges:
        for imges in addImges:
            line=line+'<div class="item">'
            line=line+'<img src="'+imges+'" alt="..."'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+imges+'" data-label=""></div>'
    line=line+'</div>'
    line=line+'<!-- Controls -->'
    line=line+'<a class="left carousel-control" href="#carousel-example-generic" style="opacity:0.2" role="button" data-slide="prev">'
    line=line+'<span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>'
    line=line+'<span class="sr-only">Previous</span>'
    line=line+'</a>'
    line=line+'<a class="right carousel-control" href="#carousel-example-generic" style="opacity:0.2" role="button" data-slide="next">'
    line=line+'<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>'
    line=line+'<span class="sr-only">Next</span>'
    line=line+'</a></div></div>'    
    return line
def writeSummaryImags(folder=None,addImages=None):
    return writeSummaryImagsCommon(folder,addImages)

def writeProteinRationImags(_quant,folder=None):
    line='<div class="col-xs-6">'
    line=line+'<p class="blog-description" style="margin-bottom: 0px;"> Peptide Quantitative Ratio Distribution:</p>'
    line=line+'<div id="carousel-example-generic1" class="carousel slide" data-ride="carousel">'
    line=line+'<!-- Indicators -->'
    line=line+'<ol class="carousel-indicators">'
    line=line+'<li data-target="#carousel-example-generic1" data-slide-to="0" class="active"></li>'
    for q in range(1,len(_quant)):
        line=line+'<li data-target="#carousel-example-generic1" data-slide-to="'+str(q)+'"></li>'
    line=line+'</ol>'
    line=line+'<!-- Wrapper for slides -->'
    line=line+'<div class="carousel-inner" role="listbox">'
    apIn=0;
    for q in range(len(_quant)):
        sample=_quant[q].replace('/','-vs-')
        if folder:
            if os.path.exists(folder+'/Report/Data/Summary/'+sample+'_RatioDistrubition.jpg'):
                apIn=1;
                if q==0:
                    line=line+'<div class="item active">'
                else:
                    line=line+'<div class="item">'
                line=line+'<img src="Data/Summary/'+sample+'_RatioDistrubition.jpg" alt="..."'
                line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Summary/'+sample+'_RatioDistrubition.jpg" data-label=""></div>'
        else:
            apIn=1;
            if q==0:
                line=line+'<div class="item active">'
            else:
                line=line+'<div class="item">'
            line=line+'<img src="Data/Summary/'+sample+'_RatioDistrubition.jpg" alt="..."'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Summary/'+sample+'_RatioDistrubition.jpg" data-label=""></div>'
    if apIn==0:
        q=0
        for f in os.listdir(folder+'/Report/Data/Summary'):
            if f.find('_RatioDistrubition')>0 and f.find('_R')>0 and f.find('.pdf')>0: 
                if q==0:
                    line=line+'<div class="item active">'
                else:
                    line=line+'<div class="item">'
                line=line+'<img src="Data/Summary/'+f[0:f.find('.pdf')]+'.jpg" alt="..."'
                line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Summary/'+f[0:f.find('.pdf')]+'.jpg" data-label=""></div>'
                q=q+1
    line=line+'</div>'
    line=line+'<!-- Controls -->'
    line=line+'<a class="left carousel-control" href="#carousel-example-generic1" style="opacity:0.2" role="button" data-slide="prev">'
    line=line+'<span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>'
    line=line+'<span class="sr-only">Previous</span>'
    line=line+'</a>'
    line=line+'<a class="right carousel-control" href="#carousel-example-generic1" style="opacity:0.2" role="button" data-slide="next">'
    line=line+'<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>'
    line=line+'<span class="sr-only">Next</span>'
    line=line+'</a></div></div>'
    return line

def outAnnotationTable(header,idUrl,_list,idInd,outPath):
    f=open(outPath,'w')
    
    for l in getText(htmlFolder+'/header.part'):
        if l.find('class="blog-masthead navbar-fixed-top"')>-1:
            f.write('<div class="blog-masthead navbar-fixed-top hidden" >')
        else:
            f.write(l)
    f.write('<div class="col-xs-12 col-sm-12"><div class="blog-header">')
    f.write('<h1 class="blog-title">Project Report</h1>')
    f.write('<p class="lead blog-description">Mhelix Proteomics Project Report By Annotation</p>')
    f.write('</div>')
    
    line='<table class="table table-responsive table-bordered table-hover table-condensed" ><thead><tr>'
    for h in header:
        line=line+'<th>'+h+'</th>'
    line=line+'</tr>'
    line20=line
    num=0
    f.write(line)
    for _map in _list:
        line=''
        if num%2==0:
            line=line+'<tr class="success">'
        else:
            line=line+'<tr>'
        line2=line
        for m in range(len(header)):
            
            txt=''
            txt2=''
            if m==idInd:
                gos=_map['V'+str(m)].split(';')
                n=0
                for _id in gos:
                    if n==5:
                        txt2=txt2+' ....'
                    elif n<5:
                        txt2=txt2+'<a href="'+idUrl+_id+'" target="_bank">'+_id+'</a> '
                    txt=txt+'<a href="'+idUrl+_id+'" target="_bank">'+_id+'</a> '
                    n=n+1
            elif m==idInd+1:
                n=0
                gos=_map['V'+str(m)].split(';')
                for _id in gos:
                    if _id == '':
                        pass
                    else:
                        txt2=_id+';'+txt2
                        n=n+1
                    if n>4:
                        txt2=txt2+' ....'
                        break
                    
                    
                txt=_map['V'+str(m)]    
                
                
            else:
                
                txt2=_map['V'+str(m)]
                txt=_map['V'+str(m)]
            
            line=line+'<td>'+txt+'</td>'
            line2=line2+'<td>'+txt2+'</td>'
        line=line+'</tr>'
        f.write(line)
        if num<=20:
            line20=line20+line2+'</tr>'
        num=num+1
    line20=line20+'</tbody></table>'

    f.write('</tbody></table>')
    f.write('</div>')
    for line in getText(htmlFolder+'/footer.part'):
        f.write(line)    
    f.close()
    return line20
    
def writeAnnotationGO(folder,outFolder,_set):
    line='<p class="blog-description" style="">GO Annotation:</p>'
    line=line+'<p>The Gene Ontology, or GO, is a major bioinformatics initiative to unify the representation of gene and gene product attributes across all species.'
    line=line+'More specifically, the project aims to:</p><p>'
    line=line+'1. Maintain and develop its controlled vocabulary of gene and gene product attributes;</p><p>'
    line=line+'2. Annotate genes and gene products, and assimilate and disseminate annotation data;</p><p>'
    line=line+'3. Provide tools for easy access to all aspects of the data provided by the project.</p><p>'
    line=line+'The ontology covers three domains:</p><p>'
    line=line+'1. Cellular component A cellular component is just that, a component of a cell, but with the proviso that it is part of some larger object; this may be'
    line=line+'an anatomical structure (e.g. rough endoplasmic reticulum or nucleus) or a gene product group (e.g. ribosome, proteasome or a protein dimer).</p>'
    
    line=line+'<p style="margin-bottom: 0px;">Identified protein GO annotation table(Top20,<a href="CC_GOs.html" target="_blank">link All</a>):</p>'
#     annotationtoJson(folder+'/BP_GOs.txt', _set, outFolder+'/BP_GOs.json', 4)
    line=line+outAnnotationTable(['ProteinID','GO_IDs','GO_Names'], 'http://amigo.geneontology.org/amigo/term/', annotationtoHtml(folder+'/CC_GOs.txt', _set, 3), 1,outFolder+'/CC_GOs.html')
    
    line=line+'<p>2. Molecular function Molecular function describes activities, such as catalytic or binding activities, that occur at the molecular level. GO molecular'
    
    line=line+'function terms represent activities rather than the entities(molecules or complexes) that perform the actions, and do not specify where or when, or'
    line=line+'in what context, the action takes place.</p>'
    line=line+'<p style="margin-bottom: 0px;">Identified protein GO annotation table(Top20,<a href="MF_GOs.html" target="_blank">link All</a>):</p>'
    line=line+outAnnotationTable(['ProteinID','GO_IDs','GO_Names'], 'http://amigo.geneontology.org/amigo/term/', annotationtoHtml(folder+'/MF_GOs.txt', _set, 3),1, outFolder+'/MF_GOs.html')
    line=line+'<p>3. Biological process A biological process is series of events accomplished by one or more ordered assemblies of molecular functions. It can be'
    line=line+'difficult to distinguish between a biological process and a molecular function, but the general rule is that a process must have more than one'
    line=line+'distinct steps.</p>'
    line=line+'<p style="margin-bottom: 0px;">Identified protein GO annotation table(Top20,<a href="BP_GOs.html" target="_blank">link All</a>):</p>'
    line=line+outAnnotationTable(['ProteinID','GO_IDs','GO_Names'], 'http://amigo.geneontology.org/amigo/term/', annotationtoHtml(folder+'/BP_GOs.txt', _set, 3),1, outFolder+'/BP_GOs.html')
    line=line+'<p>Gene Ontology (GO) annotation proteome was derived from the <a href="http://www.ebi.ac.uk/GOA/" target="_blank">UniProt-GOA database</a>. Firstly, Converting'
    line=line+'identified protein ID to UniProt ID and then mapping to GO IDs by protein ID. If some identified proteins were not annotated by UniProt-GOA'
    line=line+'database, the InterProScan soft would be used to annotated protein\'s GO functional based on protein sequence alignment method. Then proteins'
    line=line+'were classified by Gene Ontology annotation based on three categories: biological process, cellular component and molecular function.'
    line=line+'</p>'
    return line

def writeAnnotationKEGG(folder,outFolder,_set):
    line='<p class="blog-description" style="">KEGG Annotation:</p>'
    line=line+'<p>KEGG connects known information on molecular interaction networks, such as pathways and complexes (the "Pathway" database), information'
    line=line+'about genes and proteins generated by genome projects (including the gene database) and information about biochemical compounds and'
    line=line+'reactions (including compound and reaction databases). These databases are different networks, known as the "protein network", and the'
    line=line+'"chemical universe" respectively. There are efforts in progress to add to the knowledge of KEGG, including information regarding ortholog clusters'
    line=line+'in the KEGG Orthology database. KEGG Pathways mainly including: Metabolism, Genetic Information Processing, Environmental Information'
    line=line+'Processing ,Cellular Processes, Human Diseases, Drug development <a href="http://www.kegg.jp/kegg/pathway.html" target="_blank">Kyoto Encyclopedia of Genes and Genomes (KEGG) database</a> was used to annotate protein pathway. Firstly, using KEGG online service tools KAAS to'
    line=line+'annotated protein\'s KEGG database description. Then mapping the annotation result on the KEGG pathway database using KEGG online service'
    line=line+'tools KEGG mapper.'
    line=line+'</p><p style="margin-bottom: 0px;">Identified protein KEGG annotation table(Top20,<a href="KEGG_Anno.html" target="_blank">link All</a>):</p>'
    line=line+outAnnotationTable(['ProteinID','KO_ID','Pathway_IDs','Pathway_Names'], 'http://www.kegg.jp/kegg-bin/show_pathway?', annotationtoHtml(folder+'/KEGG_Paths.txt', _set, 4),2, outFolder+'/KEGG_Anno.html')
    return line

def writeAnnotationDomain(folder,outFolder,_set):
    line='<p class="blog-description" style="">Domain Annotation:</p>'
    line=line+'A protein domain is a conserved part of a given protein sequence and structure that can evolve, function, and exist independently of the rest of the'
    line=line+'protein chain. Each domain forms a compact three-dimensional structure and often can be independently stable and folded. Many proteins consist'
    line=line+'of several structural domains. One domain may appear in a variety of different proteins. Molecular evolution uses domains as building blocks and'
    line=line+'these may be recombined in different arrangements to create proteins with different functions. Domains vary in length from between about 25'
    line=line+'amino acids up to 500 amino acids in length. The shortest domains such as zinc fingers are stabilized by metal ions or disulfide bridges. Domains'
    line=line+'often form functional units, such as the calcium-binding EF hand domain of calmodulin. Because they are independently stable, domains can be'
    line=line+'"swapped" by genetic engineering between one protein and another to make chimeric proteins.'
    line=line+'<p style="margin-bottom: 0px;">Identified protein Domain annotation table(Top20,<a href="IPR_Anno.html" target="_blank">link All</a>):</p>'
    line=line+outAnnotationTable(['ProteinID','IPR_IDs','IPR_Names'], 'http://www.ebi.ac.uk/interpro/entry/', annotationtoHtml(folder+'/Ipr_Domains.txt', _set, 3),1, outFolder+'/IPR_Anno.html')
    return line
def writeAnnotationCOG(folder,outFolder,_set):
    line='<p class="blog-description" style="">Cluster of orthologous Groups of proteins:</p>'
    line=line+'<p style="margin-bottom: 0px;">Identified protein COG annotation table(Top20,<a href="COG_ClassFuns.html" target="_blank">link All</a>):</p>'
    line=line+outAnnotationTable(['ProteinID','COG_ProteinID','BlastScore','Class_Code','Class_Description','COG_Code','COG_Description'], '#', annotationtoHtml(folder+'/COG_ClassFuns.txt', _set, 7),8, outFolder+'/COG_ClassFuns.html')
    return line
def writeAnnotationSubCelur(folder,outFolder,_set):
    line='<p class="blog-description" style="" id="SubcellularLocalization">Subcellular localization:</p>'
    line=line+'<p style="margin-bottom: 0px;">Identified protein Subcellular localization annotation table(Top20,<a href="SubCellur_locations.html" target="_blank">link All</a>):</p>'
    line=line+outAnnotationTable(['ProteinID','Subcellular localization'], '#', annotationtoHtml(folder+'/SubCellur_locations.txt', _set, 2),6, outFolder+'/SubCellur_locations.html')
    return line

def writeDiffAnnotation(folder,_quant):
    line='<div class="col-xs-12 col-sm-12" id="DiffAnnotation">'
    line=line+'<h2 class="blog-post-title lead">Difference Protein Annotation</h2>'
    for q in _quant:
        sample=q.replace('/','-vs-')
        line=line+'<div class="col-sm-6 col-md-4">'
        line=line+'<div class="thumbnail">'
        line=line+'<img src="Data/Summary/'+sample+'_ProteinRatioVocano.jpg" alt="..."'
        line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Summary/'+sample+'_ProteinRatioVocano.jpg" data-label="">'
        line=line+'<div class="caption">'
        line=line+'<h3>'+q+'</h3>'
        line=line+'<p>A lot of differentially expressed proteins were obtained in '+q+' group <strong>'+str(len(getDiffKey(folder+'/'+sample+'/up.txt')))+'</strong> Up-Regulated and <strong>'+str(len(getDiffKey(folder+'/'+sample+'/down.txt')))+'</strong> down-regulated.</p>'
        line=line+'<p><a href="Data/'+sample+'/RegulatedAnnotation.xls" class="btn btn-success" role="button">Download Annotation</a></p>'
        line=line+'</div></div></div>'
    line=line+'</div>'
    return line

def getHtmlForEnrichmentTable(_path,url,sample=None,stage=None,folderUrl=None):
    f=open(_path,'r')
    f.readline()
    lines=f.readlines()
    f.close()
    line='<table class="table table-bordered table-condensed" >'
    line=line+'<thead><tr><th>Category_Name</th><th>DiffMapping</th><th>ProteinMapping</th><th>DiffNum</th><th>ProteinNum</th><th>FoldEnrichment</th><th>Fisher\'s exact test p value</th></tr></thead><tbody>'
    _list=[]
    for l in lines:
        cols=l.rstrip().lstrip('\n').split('\t')
        lin=''
        if len(_list)%2==0:
            lin=lin+'<tr class="success">'
        else:
            lin=lin+'<tr>'
        lin=lin+'<td><a href="'+url+cols[0]+'" target="_bank">'+cols[1]+'</a></td><td>'+cols[2]+'</td><td>'+cols[3]+'</td><td>'+cols[4]+'</td><td>'+cols[5]+'</td><td>'+cols[6]+'</td><td>'
        if url=='http://www.kegg.jp/kegg-bin/show_pathway?' and sample and stage:
            if folderUrl:
                lin=lin+'<a href="'+folderUrl+'/'+cols[0]+'.html" target="_bank">'+cols[7]+'</a></td></tr>'
            else:
                lin=lin+'<a href="Data/'+sample+'/Functional_Enrichment/KEGG_IMG_'+stage+'_Regulated/'+cols[0]+'.html" target="_bank">'+cols[7]+'</a></td></tr>'
        else:
            lin=lin+cols[7]+'</td></tr>'
        
        _list.append(lin)
        if len(_list)==20:
            break
    line=line+'\n'.join(_list)+'</tbody></table>'
    
    return {'html':line,'length':len(_list)}

def getHtmlForClassificationTable(_path,url):
    f=open(_path,'r')
    header=f.readline()
    lines=f.readlines()
    f.close()
    line='<table class="table table-bordered table-condensed" >'
    line=line+'<thead><tr>'
    cols=header.rstrip().lstrip('\n').split('\t')
    for i in range(len(cols)-1):
        line=line+'<th>'+cols[i]+'</th>'
    line=line+'</tr></thead><tbody>'
    _list=[]
    for l in lines:
        cols=l.rstrip().lstrip('\n').split('\t')
        lin=''
        if len(_list)%2==0:
            lin=lin+'<tr class="success">'
        else:
            lin=lin+'<tr>'
        if url:
            lin=lin+'<td><a href="'+url+cols[0]+'" target="_bank">'+cols[0]+'</a></td>'
        else:
            lin=lin+'<td>'+cols[0]+'</td>'
        for i in range(1,len(cols)-1):
            lin=lin+'<td>'+cols[i]+'</td>'
        _list.append(lin)
    line=line+'\n'.join(_list)+'</tbody></table>'
    return {'html':line,'length':len(_list)}

def writeDiffGOEnrichentPart(outfolder,sample,stage):
    line='<ul class="nav nav-tabs nav-justified tabs">'
    line=line+'<li role="presentation" class="active"><a href="#'+sample+'_EGO_'+stage+'_All">All-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_EGO_'+stage+'_Up">Up-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_EGO_'+stage+'_Down">Down-Regulated</a></li></ul>'
    line=line+'<div class="tab-content">'
    aud=['All','Up','Down']
    for u in aud:
        if u=='All':
            line=line+'<div class="tab-pane fade in active" id="'+sample+'_EGO_'+stage+'_'+u+'">'
        else:
            line=line+'<div class="tab-pane" id="'+sample+'_EGO_'+stage+'_'+u+'">'
        line=line+'<p style="margin-top: 10px;">Enrichment table(Top<=20,<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich.xls" target="_blank">link All</a>):</p>'
        line=line+'<p style="margin-bottom: 0px;font-size: 12px;"><strong>Note</strong>: GO terms is GO functional classification, DiffMapping is number of differentially expressed protein in a GO term, DiffNum is all the number of'
        line=line+'differentially expressed protein in all GO terms, ProteinMapping is number of quantitative protein in a GO term, ProteinNum is all the number of'
        line=line+'quantitative protein in all GO terms.</p>'
        _map=getHtmlForEnrichmentTable(outfolder+'/Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich.xls', 'http://amigo.geneontology.org/amigo/term/')
        line=line+_map['html']
        if _map['length']>1:
            line=line+'<img src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: The visualization of significantly enriched GO terms of GO function enrichment(High-resolution at:<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich.pdf" target="_blank">PDF</a>)</p>'
        if os.path.exists(outfolder+'/Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich_Scatter.jpg'):
            '''  REVIGO can't connected
            line=line+'<p style="margin-top: 10px;">In order to make the functional categories more understandable,terms were clustered according to their functional similarity using REVIGO</p>'
            line=line+'<img src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich_Scatter.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich_Scatter.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: The visualization of significantly enriched GO terms of GO function enrichment similarity cluster(High-resolution at:<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich_Scatter.pdf" target="_blank">PDF</a>)</p>'
            line=line+'<img src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich_Treemap.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich_Treemap.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: The visualization of significantly enriched GO terms of GO function enrichment similarity cluster(High-resolution at:<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_GO_'+stage+'_Enrich_Treemap.pdf" target="_blank">PDF</a>)</p>'
            '''

        if _map['length']>0:
            line=line+'<img src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_'+stage+'_View.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_'+stage+'_View.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: The visualization of significantly enriched GO terms of GO function enrichment(High-resolution at:<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_'+stage+'_View.pdf" target="_blank">PDF</a>)</p>'
        line=line+'</div>'
    line=line+'</div>'
    return line

def writePathwayImags(outfolder,sample,stage):
    line=''
    line=line+'<p class="blog-description" style="margin-bottom: 0px;"> Pathway visualization:</p>'
    line=line+'<div id="carousel-'+sample+'_'+stage+'" class="carousel slide" data-ride="carousel">'
    line=line+'<!-- Indicators -->'
    line=line+'<ol class="carousel-indicators">'
    line=line+'<li data-target="#carousel-example-generic1" data-slide-to="0" class="active"></li>'
    _pathList=[]
    for f in os.listdir(outfolder+'/Data/'+sample+'/Functional_Enrichment/KEGG_IMG_'+stage+'_Regulated/img'):
        _pathList.append(f)
    for q in range(1,len(_pathList)):
        line=line+'<li data-target="#carousel-'+sample+'_'+stage+'" data-slide-to="'+str(q)+'"></li>'
    line=line+'</ol>'
    line=line+'<!-- Wrapper for slides -->'
    line=line+'<div style="height:800px" class="carousel-inner" role="listbox">'
    for q in range(len(_pathList)):
        if q==0:
            line=line+'<div class="item active">'
        else:
            line=line+'<div class="item">'
        line=line+'<img src="Data/'+sample+'/Functional_Enrichment/KEGG_IMG_'+stage+'_Regulated/img/'+_pathList[q]+'" alt="..."'
        line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Enrichment/KEGG_IMG_'+stage+'_Regulated/img/'+_pathList[q]+'" data-label=""></div>'
        
    line=line+'</div>'
    line=line+'<!-- Controls -->'
    line=line+'<a class="left carousel-control" href="#carousel-'+sample+'_'+stage+'" style="opacity:0.2" role="button" data-slide="prev">'
    line=line+'<span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>'
    line=line+'<span class="sr-only">Previous</span>'
    line=line+'</a>'
    line=line+'<a class="right carousel-control" href="#carousel-'+sample+'_'+stage+'" style="opacity:0.2" role="button" data-slide="next">'
    line=line+'<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>'
    line=line+'<span class="sr-only">Next</span>'
    line=line+'</a></div>'
    return line

def writeDiffKEGGEnrichentPart(outfolder,sample):
    line='<ul class="nav nav-tabs nav-justified tabs">'
    line=line+'<li role="presentation" class="active"><a href="#'+sample+'_EKEGG_All">All-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_EKEGG_Up">Up-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_EKEGG_Down">Down-Regulated</a></li></ul>'
    line=line+'<div class="tab-content">'
    aud=['All','Up','Down']
    for u in aud:
        if u=='All':
            line=line+'<div class="tab-pane fade in active" id="'+sample+'_EKEGG_'+u+'">'
        else:
            line=line+'<div class="tab-pane" id="'+sample+'_EKEGG_'+u+'">'
        line=line+'<p style="margin-top: 10px;">Enrichment table(Top<=20,<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_KEGG_Enrich.xls" target="_blank">link All</a>):</p>'
        line=line+'<p style="margin-bottom: 0px;font-size: 12px;"><strong>Note</strong>: KEGG terms is KEGG functional classification, DiffMapping is number of differentially expressed protein in a KEGG term, DiffNum is all the number of'
        line=line+'differentially expressed protein in all KEGG terms, ProteinMapping is number of quantitative protein in a KEGG term, ProteinNum is all the number of'
        line=line+'quantitative protein in all KEGG terms.</p>'
        _map=getHtmlForEnrichmentTable(outfolder+'/Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_KEGG_Enrich.xls', 'http://www.kegg.jp/kegg-bin/show_pathway?',sample,u)
        line=line+_map['html']
        if _map['length']>1:
            line=line+'<img src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_KEGG_Enrich.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_KEGG_Enrich.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: The visualization of significantly enriched KEGG terms of KEGG function enrichment(High-resolution at:<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_KEGG_Enrich.pdf" target="_blank">PDF</a>)</p>'
        if _map['length']>0:
            line=line+writePathwayImags(outfolder, sample, u)
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: The pathway obtained from KEGG pathway enrichment. The proteins in bright green border are down-regulated and the proteins in red border are up-regulated and the proteins in blue border are identify</p>'
        line=line+'</div>'
    line=line+'</div>'
    return line

def writeDiffDomainEnrichentPart(outfolder,sample):
    line='<ul class="nav nav-tabs nav-justified tabs">'
    line=line+'<li role="presentation" class="active"><a href="#'+sample+'_EDomain_All">All-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_EDomain_Up">Up-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_EDomain_Down">Down-Regulated</a></li></ul>'
    line=line+'<div class="tab-content">'
    aud=['All','Up','Down']
    for u in aud:
        if u=='All':
            line=line+'<div class="tab-pane fade in active" id="'+sample+'_EDomain_'+u+'">'
        else:
            line=line+'<div class="tab-pane" id="'+sample+'_EDomain_'+u+'">'
        line=line+'<p style="margin-top: 10px;">Enrichment table(Top<=20,<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_Domain_Enrich.xls" target="_blank">link All</a>):</p>'
        line=line+'<p style="margin-bottom: 0px;font-size: 12px;"><strong>Note</strong>: Domain terms is Domain functional classification, DiffMapping is number of differentially expressed protein in a Domain term, DiffNum is all the number of'
        line=line+'differentially expressed protein in all Domain terms, ProteinMapping is number of quantitative protein in a Domain term, ProteinNum is all the number of'
        line=line+'quantitative protein in all Domain terms.</p>'
        _map=getHtmlForEnrichmentTable(outfolder+'/Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_Domain_Enrich.xls', 'http://www.ebi.ac.uk/interpro/entry/')
        line=line+_map['html']
        if _map['length']>1:
            line=line+'<img src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_Domain_Enrich.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_Domain_Enrich.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: The visualization of significantly enriched Domain terms of Domain function enrichment(High-resolution at:<a href="Data/'+sample+'/Functional_Enrichment/'+u+'_Regulated_Domain_Enrich.pdf" target="_blank">PDF</a>)</p>'
        line=line+'</div>'
    line=line+'</div>'
    return line


def writeDiffGOEnrichment(outfolder,sample):
    line='<p class="blog-description" style="margin-top: 10px">GO Enrichment:</p>'
    line=line+'<p>In GO enrichment analysis, firstly, we calculate the number (a) of differentially expressed protein and the number (b) of all quantitative protein in'
    line=line+'each GO term. And then calculate the total number (c) of differentially expressed protein annotated by GO terms and the total number (d) of all'
    line=line+'quantitative protein annotated by GO terms. Finally, we use the four numbers (a, b, c, d) to calculate Fisher\' exact test P values and enrichment'
    line=line+'folds. Fold enrichment = (a/c) / (b/d).</p>'
    line=line+'<p>1.GO enrichment analysis for Cellular component:</p>'
    line=line+writeDiffGOEnrichentPart(outfolder, sample, 'CC')
    line=line+'<p>2.GO enrichment analysis for Molecular function:</p>'
    line=line+writeDiffGOEnrichentPart(outfolder, sample, 'MF')
    line=line+'<p>3.GO enrichment analysis for Biological process:</p>'
    line=line+writeDiffGOEnrichentPart(outfolder, sample, 'BP')
    return line

def writeDiffKEGGEnrichment(outfolder,sample):
    line='<p class="blog-description" style="margin-top: 10px">KEGG Enrichment:</p>'
    line=line+'<p>In KEGG enrichment analysis, firstly, we calculate the number (a) of differentially expressed protein and the number (b) of all quantitative protein in'
    line=line+'each KEGG term. And then calculate the total number (c) of differentially expressed protein annotated by KEGG terms and the total number (d) of all'
    line=line+'quantitative protein annotated by KEGG terms. Finally, we use the four numbers (a, b, c, d) to calculate Fisher\' exact test P values and enrichment'
    line=line+'folds. Fold enrichment = (a/c) / (b/d).</p>'
    line=line+writeDiffKEGGEnrichentPart(outfolder, sample)
    return line

def writeDiffDomainEnrichment(outfolder,sample):
    line='<p class="blog-description" style="margin-top: 10px">Domain Enrichment:</p>'
    line=line+'<p>In Domain enrichment analysis, firstly, we calculate the number (a) of differentially expressed protein and the number (b) of all quantitative protein in'
    line=line+'each Domain term. And then calculate the total number (c) of differentially expressed protein annotated by Domain terms and the total number (d) of all'
    line=line+'quantitative protein annotated by Domain terms. Finally, we use the four numbers (a, b, c, d) to calculate Fisher\' exact test P values and enrichment'
    line=line+'folds. Fold enrichment = (a/c) / (b/d).</p>'
    line=line+writeDiffDomainEnrichentPart(outfolder, sample)
    return line

def writeDiffEnrichment(folder,_quant,outfolder):
    line='<div class="col-xs-12 col-sm-12" id="DiffEnrichment">'
    line=line+'<h2 class="blog-post-title lead">Difference Protein Functional Enrichment</h2>'
    line=line+'<ul class="nav nav-tabs">'
    for q in range(len(_quant)):
        sample=_quant[q].replace('/','-vs-')
        if q==0:
            line=line+'<li role="presentation" class="active"><a href="#'+sample+'" data-toggle="tab">'+_quant[q]+'</a></li>'
        else:
            line=line+'<li role="presentation"><a href="#'+sample+'" data-toggle="tab">'+_quant[q]+'</a></li>'
    line=line+'</ul>'
    line=line+'<div class="tab-content">'
    for q in range(len(_quant)):
        sample=_quant[q].replace('/','-vs-')
        if q==0:
            line=line+'<div class="tab-pane fade in active" id="'+sample+'">'
        else:
            line=line+'<div class="tab-pane fade" id="'+sample+'">'
        line=line+writeDiffGOEnrichment(outfolder, sample)
        line=line+writeDiffKEGGEnrichment(outfolder, sample)
        line=line+writeDiffDomainEnrichment(outfolder, sample)
        line=line+'</div>'
    line=line+'</div></div>'
    return line

def writeDiffClassificationGOPart(outfolder,sample,note,url=None):
    line='<ul class="nav nav-tabs nav-justified tabs">'
    line=line+'<li role="presentation" class="active"><a href="#'+sample+'_C_GO_All">All-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_C_GO_Up">Up-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_C_GO_Down">Down-Regulated</a></li></ul>'
    line=line+'<div class="tab-content">'
    aud=['All','Up','Down']
    for u in aud:
        if u=='All':
            line=line+'<div class="tab-pane fade in active" id="'+sample+'_C_GO_'+u+'">'
        else:
            line=line+'<div class="tab-pane" id="'+sample+'_C_GO_'+u+'">'
        line=line+'<p style="margin-top: 10px;">1.GO enrichment analysis for Cellular component Functional Classification table(Top<=20,<a href="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_CC_Level2.xls" target="_blank">link All</a>):</p>'
        line=line+'<p style="margin-bottom: 0px;font-size: 12px;"><strong>Note</strong>: '+note+'</p>'
        _map=getHtmlForClassificationTable(outfolder+'/Data/'+sample+'/Functional_Classification/'+u+'_Regulated_CC_Level2.xls', url)
        line=line+_map['html']
        line=line+'<p style="margin-top: 10px;">2.GO enrichment analysis for Molecular function Functional Classification table(Top<=20,<a href="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_MF_Level2.xls" target="_blank">link All</a>):</p>'
        line=line+'<p style="margin-bottom: 0px;font-size: 12px;"><strong>Note</strong>: '+note+'</p>'
        _map=getHtmlForClassificationTable(outfolder+'/Data/'+sample+'/Functional_Classification/'+u+'_Regulated_MF_Level2.xls', url)
        line=line+_map['html']
        line=line+'<p style="margin-top: 10px;">3.GO enrichment analysis for Biological process Functional Classification table(Top<=20,<a href="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_BP_Level2.xls" target="_blank">link All</a>):</p>'
        line=line+'<p style="margin-bottom: 0px;font-size: 12px;"><strong>Note</strong>: '+note+'</p>'
        _map=getHtmlForClassificationTable(outfolder+'/Data/'+sample+'/Functional_Classification/'+u+'_Regulated_BP_Level2.xls', url)
        line=line+_map['html']        
        line=line+'<img src="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_Level2.jpg" alt="..." class="img-thumbnail"'
        line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_Level2.jpg" data-label="">'
        line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: High-resolution at:<a href="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_Level2.pdf" target="_blank">PDF</a></p>'

        line=line+'<img src="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_Level2_tm.jpg" alt="..." class="img-thumbnail"'
        line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_Level2_tm.jpg" data-label="">'
        line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: High-resolution at:<a href="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_Level2_tm.pdf" target="_blank">PDF</a></p>'

        line=line+'</div>'
    line=line+'</div>'
    return line

def writeDiffClassificationPart(outfolder,sample,stage,note,url=None):
    line='<ul class="nav nav-tabs nav-justified tabs">'
    line=line+'<li role="presentation" class="active"><a href="#'+sample+'_C_'+stage+'_All">All-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_C_'+stage+'_Up">Up-Regulated</a></li>'
    line=line+'<li role="presentation"><a href="#'+sample+'_C_'+stage+'_Down">Down-Regulated</a></li></ul>'
    line=line+'<div class="tab-content">'
    aud=['All','Up','Down']
    for u in aud:
        if u=='All':
            line=line+'<div class="tab-pane fade in active" id="'+sample+'_C_'+stage+'_'+u+'">'
        else:
            line=line+'<div class="tab-pane" id="'+sample+'_C_'+stage+'_'+u+'">'
        line=line+'<p style="margin-top: 10px;">Functional Classification table(Top<=20,<a href="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_'+stage+'.xls" target="_blank">link All</a>):</p>'
        line=line+'<p style="margin-bottom: 0px;font-size: 12px;"><strong>Note</strong>: '+note+'</p>'
        _map=getHtmlForClassificationTable(outfolder+'/Data/'+sample+'/Functional_Classification/'+u+'_Regulated_'+stage+'.xls', url)
        line=line+_map['html']
        if _map['length']>0:
            line=line+'<img src="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_'+stage+'.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_'+stage+'.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: High-resolution at:<a href="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_'+stage+'.pdf" target="_blank">PDF</a></p>'
            
#             line=line+'<img src="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_'+stage+'.jpg" alt="..." class="img-thumbnail"'
#             line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_'+stage+'.jpg" data-label="">'
#             line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note</strong>: High-resolution at:<a href="Data/'+sample+'/Functional_Classification/'+u+'_Regulated_'+stage+'.pdf" target="_blank">PDF</a></p>'

        line=line+'</div>'
    line=line+'</div>'
    return line


def writeDiffClassification(outfolder,sample):
    line='<p class="blog-description" style="margin-top: 10px">GO Classification of Terms Level 2:</p>'
    line=line+'<p>According to GO annotation information of identified proteins, we calculated the number of differentially expressed proteins in each GO term of level 2.</p>'
    line=line+writeDiffClassificationGOPart(outfolder, sample,'The GO terms of level 2 distribution of proteins', 'http://amigo.geneontology.org/amigo/term/')
    line=line+'<p class="blog-description" style="margin-top: 10px">COG/KOG Classification of Terms:</p>'
    line=line+'<p>According to COG/KOG annotation information of identified proteins, we calculated the number of differentially expressed proteins in each COG/KOG term.</p>'
    line=line+writeDiffClassificationPart(outfolder, sample,'COG','The COG terms distribution of proteins')
    line=line+'<p class="blog-description" style="margin-top: 10px">SubCellular Location Classification of Terms:</p>'
    line=line+'<p>According to SubCellularLocation annotation information of identified proteins, we calculated the number of differentially expressed proteins in each SubCellularLocation.</p>'
    line=line+writeDiffClassificationPart(outfolder, sample,'SubCellularLocation','The SubCellularLocation terms distribution of proteins')    
    return line
    
    
def writeDiffFunctionalClassification(folder,_quant,outfolder):
    line='<div class="col-xs-12 col-sm-12" id="DiffClassification">'
    line=line+'<h2 class="blog-post-title lead">Difference Protein Functional Classification</h2>'
    line=line+'<ul class="nav nav-tabs tabs">'
    for q in range(len(_quant)):
        sample=_quant[q].replace('/','-vs-')
        if q==0:
            line=line+'<li role="presentation" class="active"><a href="#'+sample+'_C">'+_quant[q]+'</a></li>'
        else:
            line=line+'<li role="presentation"><a href="#'+sample+'_C">'+_quant[q]+'</a></li>'
    line=line+'</ul>'
    line=line+'<div class="tab-content">'
    for q in range(len(_quant)):
        sample=_quant[q].replace('/','-vs-')
        if q==0:
            line=line+'<div class="tab-pane fade in active" id="'+sample+'_C">'
        else:
            line=line+'<div class="tab-pane fade" id="'+sample+'_C">'
        line=line+writeDiffClassification(outfolder, sample)
#         line=line+writeDiffKEGGEnrichment(outfolder, sample)
#         line=line+writeDiffDomainEnrichment(outfolder, sample)
        line=line
        line=line+'</div>'
    line=line+'</div></div>'
    return line

def writeFunctionCluster(folder):
    line='<div class="col-xs-12 col-sm-12" id="FunctionCluster">'
    if os.path.exists(folder+'/Cluster'):
        line=line+'<h2 class="blog-post-title lead">Functional Enrichment-based Clustering for Protein Groups</h2>'
    else:
        line=line+'<h2 class="blog-post-title lead">Functional Enrichment-based Clustering for Quantitative Category</h2>'
        line=line+'<p style="margin-bottom: 0px;">The quantifiable proteins in this study were divided into four quantitative categories according to their ratios: Q1,Q2,Q3 and Q4.Then, the quantifiable proteins from the four categories were plotted for GO、KEGG、Domain enrichment-based cluster analysis</p>'
        line=line+'<img src="Data/Cluster/QClass.jpg" alt="..." class="img-thumbnail"'
        line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Cluster/QClass.jpg" data-label="">'
        line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>Distribution of quantification results: High-resolution at:<a href="Data/Cluster/QClass.pdf" target="_blank">PDF</a></p>'
    if os.path.exists(folder+'/Cluster/Up'):
        line=line+'<div>'
        line=line+'<ul class="nav nav-tabs nav-justified tabs">'
        line=line+'<li role="presentation" class="active"><a href="#Cluster_All">All-Regulated</a></li>'
        line=line+'<li role="presentation"><a href="#Cluster_Up">Up-Regulated</a></li>'
        line=line+'<li role="presentation"><a href="#Cluster_Down">Down-Regulated</a></li></ul>'
        line=line+'<div class="tab-content">'
        aud=['All','Up','Down']
        for u in aud:
            if u=='All':
                line=line+'<div class="tab-pane fade in active" id="Cluster_All">'
            else:
                line=line+'<div class="tab-pane" id="Cluster_'+u+'">'
            line=line+writeCluster('Data/Cluster/'+u,False)
            line=line+'</div>'
        line=line+'</div>'
        line=line+'</div>'
    else:
        flag=True
        for f in os.listdir(folder+'/Cluster'):
            if f.find('Cluster_')==0 and not os.path.isfile(folder+'/Cluster/'+f):
                line=line+'<div>'
                line=line+'<ul class="nav nav-tabs nav-justified tabs">'
                line=line+'<li role="presentation" class="active"><a href="#'+f+'Cluster_All">All-Regulated</a></li>'
                line=line+'<li role="presentation"><a href="#'+f+'Cluster_Up">Up-Regulated</a></li>'
                line=line+'<li role="presentation"><a href="#'+f+'Cluster_Down">Down-Regulated</a></li></ul>'
                line=line+'<div class="tab-content">'
                aud=['All','Up','Down']
                for u in aud:
                    if u=='All':
                        line=line+'<div class="tab-pane fade in active" id="'+f+'Cluster_All">'
                    else:
                        line=line+'<div class="tab-pane" id="'+f+'Cluster_'+u+'">'
                    line=line+writeCluster('Data/Cluster/'+f+'/'+u,False)
                    line=line+'</div>'
                line=line+'</div>'
                line=line+'</div>'
                flag=False
        if flag:
            line=line+writeCluster('Data/Cluster')
    line=line+'</div>'
    return line

def writeCluster(outFolder,leaf=True):
    line1='<img src="'+outFolder+'/KEGG_Cluster.jpg" alt="..." class="img-thumbnail"'
    line1=line1+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+outFolder+'/KEGG_Cluster.jpg" data-label="">'
    line1=line1+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>KEGG Pathway function cluster: High-resolution at:<a href="'+outFolder+'/KEGG_Cluster.pdf" target="_blank">PDF</a></p>'

    line1=line1+'<img src="'+outFolder+'/Domain_Cluster.jpg" alt="..." class="img-thumbnail"'
    line1=line1+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+outFolder+'/Domain_Cluster.jpg" data-label="">'
    line1=line1+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>Domain function cluster: High-resolution at:<a href="'+outFolder+'/Domain_Cluster.pdf" target="_blank">PDF</a></p>'
    '''
    if leaf:
        line1=line1+'<img src="'+outFolder+'/GO_MF_Leaf_Cluster.jpg" alt="..." class="img-thumbnail"'
        line1=line1+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+outFolder+'/GO_MF_Leaf_Cluster.jpg" data-label="">'
        line1=line1+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>GO Molecular function leaf function cluster: High-resolution at:<a href="'+outFolder+'/GO_MF_Leaf_Cluster.pdf" target="_blank">PDF</a></p>'
        
        line1=line1+'<img src="'+outFolder+'/GO_CC_Leaf_Cluster.jpg" alt="..." class="img-thumbnail"'
        line1=line1+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+outFolder+'/GO_CC_Leaf_Cluster.jpg" data-label="">'
        line1=line1+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>GO Cellular component leaf function cluster: High-resolution at:<a href="'+outFolder+'/GO_CC_Leaf_Cluster.pdf" target="_blank">PDF</a></p>'
    if leaf:
        line1=line1+'<img src="'+outFolder+'/GO_BP_Leaf_Cluster.jpg" alt="..." class="img-thumbnail"'
        line1=line1+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+outFolder+'/GO_BP_Leaf_Cluster.jpg" data-label="">'
        line1=line1+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>GO Biological process leaf function cluster: High-resolution at:<a href="'+outFolder+'/GO_BP_Leaf_Cluster.pdf" target="_blank">PDF</a></p>'
    '''
    line1=line1+'<img src="'+outFolder+'/GO_MF_Cluster.jpg" alt="..." class="img-thumbnail"'
    line1=line1+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+outFolder+'/GO_MF_Cluster.jpg" data-label="">'
    line1=line1+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>GO Molecular function function cluster: High-resolution at:<a href="'+outFolder+'/GO_MF_Cluster.pdf" target="_blank">PDF</a></p>'
    
    line1=line1+'<img src="'+outFolder+'/GO_CC_Cluster.jpg" alt="..." class="img-thumbnail"'
    line1=line1+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+outFolder+'/GO_CC_Cluster.jpg" data-label="">'
    line1=line1+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>GO Cellular component function cluster: High-resolution at:<a href="'+outFolder+'/GO_CC_Cluster.pdf" target="_blank">PDF</a></p>'
            
    line1=line1+'<img src="'+outFolder+'/GO_BP_Cluster.jpg" alt="..." class="img-thumbnail"'
    line1=line1+' data-toggle="modal" data-target="#myModal" data-title="" data-src="'+outFolder+'/GO_BP_Cluster.jpg" data-label="">'
    line1=line1+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>GO Biological process function cluster: High-resolution at:<a href="'+outFolder+'/GO_BP_Cluster.pdf" target="_blank">PDF</a></p>'
    return line1

def writeAdditional(outfolder):
    line='<div class="col-xs-12 col-sm-12" id="Additional">'
    if os.path.exists(outfolder+'/Data/Repeatability'):
        line=line+'<h2 class="blog-post-title lead">Repeatability analysis:</h2>'
        
        line=line+'<img src="Data/Repeatability/Repeatability_proCor.png" alt="..." class="img-thumbnail"'
        line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Repeatability/Repeatability_proCor.png" data-label="">'
        line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>High-resolution at:<a href="Data/Repeatability/Repeatability_proCor.pdf" target="_blank">PDF</a></p>'
    if os.path.exists(outfolder+'/Data/iPath'):
        line=line+'<h2 class="blog-post-title lead">Interactive Pathways Explorer analysis:</h2>'
        _list=[]
        for f in os.listdir(outfolder+'/Data/iPath'):
            if not os.path.isfile(outfolder+'/Data/iPath/'+f) and os.path.exists(outfolder+'/Data/iPath/'+f+'/Metabolic.pdf'):
                _list.append(f)
        for f in _list:
            line=line+'<h4 class="blog-description">Metabolic pathways: constructed using 146 KEGG pathways, and gives an overview of the complete metabolism in biological systems</h4>'
            line=line+'<h4 class="blog-description">Regulated in '+f+':</h4>'
            line=line+'<img src="Data/iPath/'+f+'/Metabolic.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/iPath/'+f+'/Metabolic.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>High-resolution at:<a href="Data/iPath/'+f+'/Metabolic.pdf" target="_blank">PDF</a></p>'
    
            line=line+'<h4 class="blog-description">Biosynthesis of secondary metabolites: contains 58 KEGG pathways involved in biosynthesis of secondary metabolites</h4>'
            line=line+'<h4 class="blog-description">Regulated in '+f+':</h4>'
            line=line+'<img src="Data/iPath/'+f+'/Biosynthesis.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/iPath/'+f+'/Biosynthesis.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>High-resolution at:<a href="Data/iPath/'+f+'/Biosynthesis.pdf" target="_blank">PDF</a></p>'
    
            line=line+'<h4 class="blog-description">Regulatory pathways: 22 KEGG regulatory pathways</h4>'
            line=line+'<h4 class="blog-description">Regulated in '+f+':</h4>'
            line=line+'<img src="Data/iPath/'+f+'/Regulatory.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/iPath/'+f+'/Regulatory.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>High-resolution at:<a href="Data/iPath/'+f+'/Regulatory.pdf" target="_blank">PDF</a></p>'
         
    if os.path.exists(outfolder+'/Data/Network'):
        line=line+'<h2 class="blog-post-title lead">PPI Network Analysis:</h2>'
        _list=[]
        for f in os.listdir(outfolder+'/Data/Network'):
            if not os.path.isfile(outfolder+'/Data/Network/'+f) and os.path.exists(outfolder+'/Data/Network/'+f+'/network.pdf'):
                _list.append(f)
        for f in _list:
            line=line+'<img src="Data/Network/'+f+'/network.jpg" alt="..." class="img-thumbnail"'
            line=line+' data-toggle="modal" data-target="#myModal" data-title="" data-src="Data/Network/'+f+'/network.jpg" data-label="">'
            line=line+'<p style="margin-bottom: 10px;font-size: 12px;"><strong>Note:</strong>'+f+' regulated network:High-resolution at:<a href="Data/Network/'+f+'/network.pdf" target="_blank">PDF</a>(<a href="Network_'+f+'.html" target="_blank">Detail link</a>)</p>'
            writeNetworkHtml(outfolder,f)
    line=line+'</div>'
    return line

def writeHtml(folder,outfolder,_quant,ind='1.2&0.05'):
    copyFolder(htmlFolder+'/css', outfolder+'/css')
    copyFolder(htmlFolder+'/fonts', outfolder+'/fonts')
    copyFolder(htmlFolder+'/js', outfolder+'/js')
    fw=open(outfolder+'/Report.html','w')
    for line in getText(htmlFolder+'/header.part'):
        fw.write(line)
        
        
    fw.write(writeSampleInfo(folder, _quant, folder+'/samplesInfo.txt'))
    fw.write(writeDiffStatistics(folder, _quant,ind))
    fw.write(writeSummaryImags(folder,None))
    fw.write(writeProteinRationImags(_quant,folder))
    fw.write('<div class="col-xs-12 col-sm-12" id="Annotation"><h2 class="blog-post-title lead" style="margin-top: 30px;">Identified Protein Annotation</h2>')
    _set=set(getAllProtein(folder))
    fw.write(writeAnnotationGO(folder,outfolder,_set))
    fw.write(writeAnnotationKEGG(folder,outfolder,_set))
    fw.write(writeAnnotationDomain(folder, outfolder, _set))
    fw.write(writeAnnotationCOG(folder, outfolder, _set))
    fw.write(writeAnnotationSubCelur(folder, outfolder, _set))
    fw.write('</div>')
    fw.write(writeDiffAnnotation(folder, _quant))
    fw.write(writeDiffEnrichment(folder, _quant,outfolder))
    fw.write(writeDiffFunctionalClassification(folder, _quant, outfolder))
    fw.write(writeFunctionCluster(folder))
    fw.write(writeAdditional(outfolder))
    for line in getText(htmlFolder+'/footer.part'):
        fw.write(line)    
    fw.close()
    pass

#mSamples: map {'SampleName': list(126, 129, ...)}
#quantUp: list('SampleName1', 'SampleName2', ...) — names corresponding to mSamples, provided externally
#quantLow: list('SampleName1', 'SampleName2', ...) — names corresponding to mSamples, provided externally
#quant: comparison groups to be retained
#commonQuant: map {'A-vs-B': ['A-vs-B_Rep1', 'A-vs-B_Rep2'], 'A-vs-C': ['A-vs-C_Rep1', 'A-vs-C_Rep2']} — used for intersection of comparison groups

def mergeRepeat(folder,mSamples,quantUp,quantLow,quant,commonQuant,fc,p):
    f=open(folder+'/ProteinExprossion.txt','r')
    fw=open(folder+'/ProteinExprossion_bak.txt','w')#备份
    line=f.readline()
    fw.write(line)
    headers=line.rstrip().lstrip('\n').split('\t')
    _map={}
    _sampleInds=[]
    for key in mSamples:
        _list=[]
        for s in mSamples[key]:
            for i in range(len(headers)):
                if headers[i]==s:
                    _list.append(i)
        _sampleInds.extend(_list)    
        _map[key]=_list
    _sampleInds=list(set(_sampleInds))
    _list=[]
    for q in quant:
        for i in range(len(headers)):
            if headers[i]==q.replace('/','-vs-'):
                _list.append(i)
                _list.append(i+1)
                break
    _sampleInds.extend(_list) 
    commonHeader=[]
    for k in commonQuant:
        _list=[]
        commonHeader.append(k)
        for q in commonQuant[k]:
            for i in range(len(headers)):
                if headers[i]==q.replace('/','-vs-'):
                    _list.append(i)
                    _list.append(i+1)
                    break
        _map[k]=_list
        _sampleInds.extend(_list) 
    line=f.readline()
    _text=''
    
    while line:
        fw.write(line)
        cols=line.rstrip().lstrip('\n').split('\t')
        _line=cols[0]+'\t'+cols[1]
        for i in _sampleInds:
            _line=_line+'\t'+cols[i]
        for i in range(len(quantUp)):
            q=mergeQuant(cols, _map[quantUp[i]], _map[quantLow[i]])
            _line=_line+'\t'+q[0]+'\t'+q[1]
        for k in commonHeader:
            q=commonDiff(cols, _map[k], fc, p)
            _line=_line+'\t'+q[0]+'\t'+q[1]
        _text=_text+_line+'\n'
        line=f.readline()
    f.close()
    fw.close()
    fw=open(folder+'/ProteinExprossion.txt','w')
    fw.write(headers[0]+'\t'+headers[1])
    for i in _sampleInds:
        fw.write('\t'+headers[i])
    for i in range(len(quantUp)):
        fw.write('\t'+quantUp[i]+'-vs-'+quantLow[i]+'\t'+quantUp[i]+'-vs-'+quantLow[i]+'-p')
    for k in commonHeader:
        fw.write('\t'+k+'\t'+k+'-p')
    fw.write('\n')
    fw.write(_text)
    fw.close()

# Internal method

def mergeQuant(cols,_listUp,_listLow,p=None):    
    _upAvg=[]
    for i in _listUp:
        if p:
            if cols[i]!='NA' and cols[i+1]!='NA':
                _upAvg.append(float(cols[i]))
        else:
            if cols[i]!='NA':
                _upAvg.append(float(cols[i]))
    _lowAvg=[]
    for i in _listLow:
        if p:
            if cols[i]!='NA' and cols[i+1]!='NA':
                _lowAvg.append(float(cols[i]))
        else:
            if cols[i]!='NA':
                _lowAvg.append(float(cols[i]))
    if len(_lowAvg)>1 and len(_upAvg)>1:
        if len(_lowAvg)>2 and len(_upAvg)>2:
            _w,p=levene(_lowAvg,_upAvg)
            if p<0.05:
                print 'Variance is not equal'

                return [str(sum(_upAvg)*len(_lowAvg)/(len(_upAvg)*sum(_lowAvg))),'NA']
            else:
                _t,p=f_oneway(_lowAvg,_upAvg)
    #         t,p=ttest_ind(_lowAvg,_upAvg)
                return [str(sum(_upAvg)*len(_lowAvg)/(len(_upAvg)*sum(_lowAvg))),str(p)]
        else:
            _t,p=ttest_ind(_lowAvg,_upAvg)
            return [str(sum(_upAvg)*len(_lowAvg)/(len(_upAvg)*sum(_lowAvg))),str(p)]
    elif len(_lowAvg)==0 or len(_upAvg)==0:
        return ['NA','NA']
    else:
        return [str(sum(_upAvg)*len(_lowAvg)/(len(_upAvg)*sum(_lowAvg))),'NA']

def commonDiff(cols,_list,fc,p):
    fcs=[]
    ps=[]
    u=0
    d=0
    c=0
    for i in range(0,len(_list),2):
        if cols[_list[i+1]]!='NA':
            f1=float(cols[_list[i]])
            p1=float(cols[_list[i+1]])
            fcs.append(f1)
            ps.append(p1)
            if p1<p:
                if f1>fc:
                    u+=1
                elif f1<1.0/fc:
                    d+=1
                else:
                    c+=1
            else:
                c+=1
    if u>0 and d>0:
        return ['NA','NA']
    elif (u>0 or d>0) and c==0:
        return[str(average(fcs)),str(average(ps))]
    elif u==0 and d==0 and c>0:
        return[str(average(fcs)),str(average(ps))]
    else:
        return ['NA','NA']

def iPath2(folder,_quant):
    try:
        os.makedirs(folder+'/iPath2')
    except:
        pass
    data=pd.read_table(folder+'/ProteinExprossion.txt',header=0)
    _set=set(_quant)
    _map=getKO2Protein(folder+'/query.ko')
    for q in _quant:
        lev=q.replace('/','-vs-')
        try:
            os.makedirs(folder+'/iPath2/'+lev)
        except:
            pass
        level=data[['Protein',lev]]
        
        up=getDiffKey(folder+'/'+lev+'/up.txt')
        down=getDiffKey(folder+'/'+lev+'/down.txt')
        fw=open(folder+'/iPath2/'+lev+'/queryList.txt','w')
        for i in range(len(level['Protein'])):
            if _map.has_key(level['Protein'][i]) and level[lev][i]>0 and level[lev][i]<100:
                if level['Protein'][i] in down:
                    fw.write(_map[level['Protein'][i]]+' W8 #00CC00\n')#green
                elif level['Protein'][i] in up:
                    fw.write(_map[level['Protein'][i]]+' W8 #ff0000\n')#red
                else:
                    fw.write(_map[level['Protein'][i]]+' W6 #003366\n')#blue
            elif _map.has_key(level['Protein'][i]):
                fw.write(_map[level['Protein'][i]]+' W6 #996699\n')#zise
        fw.close()
        for uda in ['Up','Down','All']:
            upMap=getEnrichResult(folder+'/'+lev+'/'+uda+'_KEGG_Enrich.txt.tmp')
            try:
                os.makedirs(folder+'/iPath2/'+lev+'/'+uda+'_Map')
            except:
                pass
            fw=open(folder+'/iPath2/'+lev+'/'+uda+'_Map/queryList.txt','w')
            for key in upMap:
                p=-math.log10(float(upMap[key]))
                if p>3:
                    p=3
                if p>2:
                    fw.write(key[3:key.find('~')]+' W'+str(8+p*5)+' #ff0000\n')
                elif p>-math.log10(0.05):
                    fw.write(key[3:key.find('~')]+' W'+str(8+p*5)+' #00CC00\n')
                else:
                    fw.write(key[3:key.find('~')]+' W'+str(8+p*5)+' #996699\n')
            fw.close()        
def networks(folder,quant):
    _all=set([])
    for q in quant:
        _all=_all|network(folder, q)
    fw=open(folder+'/Network/Nodes.txt','w')
    for p in _all:
        fw.write(p+'\n')
    fw.close()
def network(folder,q):
    lev=q.replace('/','-vs-')
    try:
        if not os.path.exists(folder+'/Network'):
            os.makedirs(folder+'/Network')
        os.makedirs(folder+'/Network/'+lev)
    except:
        pass
    fw=open(folder+'/Network/'+lev+'/Nodes.txt','w')
    _up=getDiffKey(folder+'/'+lev+'/up.txt')
    _Down=getDiffKey(folder+'/'+lev+'/down.txt')
    for key in _up:
        fw.write(key+'\n')
    for key in _Down:
        fw.write(key+'\n')
    fw.close()
    return _up|_Down
    
def enrichment(folder, quant,full=0):
    outGOEnrichment(folder, quant,full)
    outDomainEnrichment(folder,quant,full)
    outKEGGEnrichment(folder,quant,full)
def classFunction(folder, quant):
    writeClassFunctionGO(folder, quant)
    writeClassFunctionCOG(folder, quant)
    writeClassFunctionKEGG(folder, quant)
    writeClassFunctionSubCelurLocation(folder, quant)

def qCluster(folder, quant,q,full=1):
    print(quant)
    splitQ(folder, quant,q)
    outKEGGEnrichmentQ(folder, quant,full)
    outGOEnrichmentQ(folder, quant,full)
    outDomainEnrichmentQ(folder, quant,full)
    mergeQEnrichmentAll(folder, quant)    

def appendRepeat(folder,_quant,_quantRep):
    _map={}
    for q in quant:
        if q[0:q.find('_Rep')] in set(_quantRep):
            if _map.has_key(q[0:q.find('_Rep')]):
                _map[q[0:q.find('_Rep')]].append(q)
            else:
                _map[q[0:q.find('_Rep')]]=[q]
    for key in _map:
        levKey=key.replace('/','-vs-')
        try:
            os.mkdir(folder+'/'+levKey)
        except:
            pass
        _up=None
        _down=None
        for q in _map[key]:
            lev=q.replace('/','-vs-')
            up1=getLineDatas(folder+'/'+lev+'/up.txt')
            down1=getLineDatas(folder+'/'+lev+'/down.txt')
            if not _up:
                _up=up1
                _down=down1
            else:
                _up=getCommonList(_up, up1)
                _down=getCommonList(_down, down1)
        f=open(folder+'/'+levKey+'/up.txt','w')
        f.write('\n'.join(_up))
        f.close()
        f=open(folder+'/'+levKey+'/down.txt','w')
        f.write('\n'.join(_down))
        f.close() 

def appendProteinExprossion(folder,quantRep):
    _list=[]
    header=''
    for q in quantRep:
        lev=q.replace('/', '-vs-')
        header=header+'\t'+lev+'\t'+lev+'-p'
        up=getLineDatas(folder+'/'+lev+'/up.txt')
        down=getLineDatas(folder+'/'+lev+'/down.txt')
        _list.append((set(up),set(down)))
    
    copyFile(folder+'/ProteinExprossion.txt', folder+'/ProteinExprossion.txt.bak')
    f=open(folder+'/ProteinExprossion.txt','r')
    lines=f.readlines()
    f.close()
    f=open(folder+'/ProteinExprossion.txt','w')
    for line in lines:
        line=line.rstrip('\n')
        cols=line.split('\t')
        if cols[0]=='Protein':
            line=line+header+'\n'
        else:
            li=''
            for i in range(len(quantRep)):
                if cols[0] in _list[i][0]:
                    li=li+'\t2.1\t0.0001'
                elif cols[0] in _list[i][1]:
                    li=li+'\t0.4\t0.0001'
                else:
                    li=li+'\t1\t1'
            line=line+li+'\n'
        f.write(line)
    f.close()
def repeatHeader(folder,_quant):
    f=open(folder+'/ProteinExprossion.txt','r+')
    flist=f.readlines()
    f.close()
    cols=flist[0].rstrip('\n').split('\t')
    _map={}
    for i in range(len(cols)):
        if cols[i].replace('-vs-','/') in set(_quant) and _map.has_key(cols[i]):
            _map[cols[i]].append(i)
        elif cols[i].replace('-vs-','/') in set(_quant):
            _map[cols[i]]=[i]
    for key in _map:
        for j in range(len(_map[key])):
            cols[_map[key][j]]=cols[_map[key][j]]+'_Rep'+str(j+1)
            cols[_map[key][j]+1]=cols[_map[key][j]]+'-p'
    
    flist[0]='\t'.join(cols)+'\n'
    f=open(folder+'/ProteinExprossion.txt','w+')
    f.writelines(flist)
    f.close()


#reps=['Rep1','Rep2']
# quants=[['q1','q2'],['q1','q2']]
#end=True:append end of Rep
def mergeReps(folder,reps,quants,end=True):
    _paths=[]
    for p in reps:
        _paths.append((p,folder+'/'+p+'/ProteinExprossion.txt'))
#     print _paths
    _listMap=[]
    _keys=[]
    for x in range(len(_paths)):
        _p=_paths[x]
        dm=getDataMatrix(_p[1])
        _inds=[]
        for lev in quants[x]:
            lev=lev.replace('/', '-vs-')
            for i in range(len(dm[0][0])):
                if lev==dm[0][0][i]:
                    _inds.append(i)
                    break
        _map={}
        if len(_inds)==len(quants[x]):
            _map['header']=getListByList(dm[0][0], _inds)
            for i in range(1,len(dm[0])):
                _keys.append(dm[0][i][0]+'\t'+dm[0][i][1])
                _map[dm[0][i][0]+'\t'+dm[0][i][1]]=getListByList(dm[0][i], _inds)
        else:
            print '----miss value'
        _listMap.append(_map)
    fw=open(folder+'/ProteinExprossion.txt','w')
    fw.write('Protein\tProteinName')
    for i in range(len(_listMap)):
        fw.write('\t'+'\t'.join(getAppendTxt(_listMap[i]['header'],'Rep'+str(i+1),end)))
    fw.write('\n')
    for key in set(_keys):
        fw.write(key)
        for i in range(len(_listMap)):
            if _listMap[i].has_key(key):
                fw.write('\t'+'\t'.join(_listMap[i][key]))
            else:
                fw.write('\t'+'\t'.join(getNA(_inds)))
        fw.write('\n')
    fw.close()

def getAppendTxt(_list,txt,end=True):
    _l=[]
    for _i in _list:
        if end:
            _l.append(_i+'_'+txt)
        else:
            _l.append(_i)
    return _l           
        
def getNA(_inds):
    _l=[]
    for _i in _inds:
        _l.append('NA\tNA')
    return _l           
    
def getListByList(_list,_inds):
    _l=[]
    for _i in _inds:
        _l.append(_list[_i])
        _l.append(_list[_i+1])
    return _l           

def writeCommonDiff(folder,_quant,_commonMap):
    for key in _commonMap:
        _up=None
        _down=None
        for i in _commonMap[key]:
            lev=_quant[i].replace('/','-vs-')
            up1=getLineDatas(folder+'/'+lev+'/up.txt')
            down1=getLineDatas(folder+'/'+lev+'/down.txt')
            if _up:
                _up=getCommonList(_up, up1)
            else:
                _up=up1
            if _down:
                _down=getCommonList(_down, down1)
            else:
                _down=down1
        try:
            os.mkdir(folder+'/'+key.replace('/','-vs-'))
        except:
            pass
        fw=open(folder+'/'+key.replace('/','-vs-')+'/up.txt','w')
        fw.write('\n'.join(_up))
        fw.close()
        fw=open(folder+'/'+key.replace('/','-vs-')+'/down.txt','w')
        fw.write('\n'.join(_down))
        fw.close()    

def repeatability(folder,mSamples):
    if os.path.exists(folder+'/pepRatio.expro'):
        repeatabilityCor(folder, mSamples,folder+'/pepRatio.expro',folder+'/Repeatability_pepCor')
        repeatabilityCV(folder, mSamples,folder+'/pepRatio.expro',folder+'/Repeatability_pepCV')
    if os.path.exists(folder+'/ProteinExprossion_bak.txt'):
        repeatabilityCor(folder, mSamples,folder+'/ProteinExprossion_bak.txt',folder+'/Repeatability_proCor')
        repeatabilityCV(folder, mSamples,folder+'/ProteinExprossion_bak.txt',folder+'/Repeatability_proCV')
    else:
        repeatabilityCor(folder, mSamples,folder+'/ProteinExprossion.txt',folder+'/Report/Data/Repeatability/Repeatability_proCor')
        repeatabilityCV(folder, mSamples,folder+'/ProteinExprossion.txt',folder+'/Repeatability_proCV')
    
def repeatabilityCV(folder,mSamples,path,outPath):
    data=getDataMatrix(path)[0]
    _map={}
    for key in mSamples:
        _listInd=[]
        for s in mSamples[key]:
            for i in range(len(data[0])):
                if data[0][i]==s:
                    _listInd.append(i)
                    break    
        _map[key]=_listInd
    print _map
    cvMap={}
    for i in range(1,len(data)):
        cols=data[i]
        for key in mSamples:
            fs=[]
            for j in _map[key]:
                if cols[j]=='NA':
                    break
                else:
                    try:
                        fs.append(float(cols[j]))
                    except:
                        pass
            if len(fs)==len(_map[key]):
                if cvMap.has_key(key):
                    cvMap[key].append(getCV(fs))
                else:
                    cvMap[key]=[getCV(fs)]
    _cvData={}
    for key in cvMap:
        cv=sorted(cvMap[key])
        _cvList=[(0,0)]
        for i in range(100):
            for j in range(len(cv)):
                if cv[j]>=i/100.0:
                    _cvList.append((i+1,(j*1.0)/len(cv)))
                    break
        _cvData[key]=_cvList
    plotRepeatabilityCV(_cvData,outPath)
    
    
def getCV(_list):
    return np.std(_list)/np.mean(_list)    
    
def repeatabilityCor(folder,mSamples,path,outPath):
    data=getDataMatrix(path)[0]
    _list=[]
    _listInd=[]
    _map={}
    for key in mSamples:
        for s in mSamples[key]:
            _list.append(s)
            _map[s]=[]
            for i in range(len(data[0])):
                if data[0][i]==s:
                    _listInd.append(i)
                    break
    print _listInd
    for i in range(1,len(data)):
        cols=data[i]
        fs=[]
        for j in range(len(_list)):
            print cols[_listInd[j]]
            if cols[_listInd[j]]=='NA':
                break
            else:
                try:
                    fs.append(float(cols[_listInd[j]]))
                except:
                    pass
        if len(fs)==len(_list):
            for j in range(len(_list)):
                _map[_list[j]].append(fs[j])
    plotRepeatabilityCor(_map,outPath)

def topGo(folder,quant):
    samples=[]
    for q in quant:
        samples.append(q.replace('/', '-vs-'))
    p = subprocess.Popen('Rscript   /home/fy/Biosoft/miniconda2/lib/python2.7/site-packages/com/mh/Rscript/TopGo.r '+folder+' '+','.join(samples), shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    for line in p.stdout.readlines():
        print line
    p.wait()

def plotQuant(folder,quant):
    samples=[]
    for q in quant:
        samples.append(q.replace('/', '-vs-'))
    
    p = subprocess.Popen('Rscript /home/mowq/Proteomes/project/lianxi/Rscript/ITRAQSummaryReport.r '+folder+' '+','.join(samples)+' '+','.join(repeats), shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    
    #for line in p.stdout.readlines():
    #    print line
    p.wait()
    p = subprocess.Popen('Rscript   /home/fy/Biosoft/miniconda2/lib/python2.7/site-packages/com/mh/Rscript/PlotITRAQQuant.r '+folder+' '+','.join(samples), shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    #for line in p.stdout.readlines():
     #   print line
    p.wait()
    p = subprocess.Popen('Rscript   /home/fy/Biosoft/miniconda2/lib/python2.7/site-packages/com/mh/Rscript/ClassFunction.r '+folder+' '+','.join(samples), shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    
    '''
    for line in p.stdout.readlines():
        print line
    '''
    p.wait()
    
def plotCluster(folder):
    p = subprocess.Popen('Rscript   /home/fy/Biosoft/miniconda2/lib/python2.7/site-packages/com/mh/Rscript/EnrichmentCluster.r '+folder, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    
    for line in p.stdout.readlines():
        print line
    
    p.wait()
os.system('perl /home/Mouhe/Pipeline/QuantitativeProteomics/bin/Sed_ZeroExpression.pl -r ./ProteinExprossion.txt')
 os.system('python /home/mowq/Proteomes/need/GetCol.py  ' + folder) #need Reps.txt sep by \t
 os.system('python /home/laicl/laichunling/need/QC/GetCol_maxquant.py  ' + folder) 

# step1 Data Quality Control and Data Preproceig 
   parseQuantDiff(quant,folder,None)
# step2 Differential Expression Analysis
   prosessCutDiff(quant, folder, fold, pval,None)
# step3 Amino Acid Sequence Extraction 
   outFastaByKey(set(getAllProtein(folder)), folder+soku, folder+'/identify.fasta')
# step4 GO Annotation
   os.system('sh /home/hxl/work/proteomics/needs/goblast.sh '+folder)
   processGOAnnotation(folder)
# step5 COG Annotation
   os.system('sh /home/hxl/work/proteomics/needs/cog.sh ' + folder + ' 1> cog.log 2> cog.err')
   os.system('sh /home/hxl/work/proteomics/needs/COG_annotation.sh ' + folder )
   os.system('sh /home/hxl/work/proteomics/needs/kog.sh ' + folder + ' 1>kog.log 2>kog.err')
   parseBlastByM8(folder + "/kog.out", folder + "/seq.m8.clear.id")
   processCOGAnnotition(folder, folder+"/seq.m8.clear.id", 'kog')
   os.system('perl /home/Mouhe/Pipeline/QuantitativeProteomics/bin/Merge_COG_KOG_anno.pl  COG_ClassFuns.txt COG_ClassFuns.COGrs.txt >COG_ClassFuns.Merged.txt ')
   os.system('mv COG_ClassFuns.Merged.txt COG_ClassFuns.txt')
# step6 KEGG Annotation
   postKAAS(folder + '/identify.fasta', orgs)
   if getQueryKO('https://www.genome.jp/kaas-bin/kaas_main?mode=user&id=1616494811&key=GkXem0xw', '1616494811', folder + '/query.ko'):
      print 'getQueryKO successful'
   processKEGGAnnotation(folder, folder + '/query.ko', None)
# step7 Domain Annotation
   os.system('sh /home/hxl/work/proteomics/needs/inter.sh ' + folder + ' 1>inter.log 2>inter.err')
   processInterDomain(folder, folder + '/inter.domain')
# step8 Subcellular Location 
   postCelloByWorfFormat(folder, False) #bacterial     
   os.system('sh /home/hxl/work/proteomics/needs/worf.sh ' + ' animal ' + folder)  #"fungi","plant","animal"
   os.system('perl /home/hxl/work/proteomics/needs/change_worf.pl worf.temp worf.tab')
   processSubCellurLocation(folder, folder+'/worf.tab','worf')
# step9 Enrichment Process
   enrichment(folder, quant, 0)
   topGo(folder, quant)
   postREVIGO(quant)
# step10 Cluster Process
   classFunction(folder, quant)
# step11 Visualization of Enrichment and Cluster
   mergeEnrichmentAll(folder, quant)
# step12 Visualization of DEP
   plotQuant(folder, quant)
   starcol = 2 + sample_number
   startcol = 14
   for temp  in quant:
       print temp
       q = temp.replace('/','-vs-')
       plotScatter(folder+'/'+'ProteinExprossion.txt',folder+'/'+q+'_ProteinRatioVocano',startcol,fold,pval,q)
       startcol = startcol + 2
       k = BoxPlot(folder+'/ProteinExprossion.txt')
   repeatability(folder,mSamples)  #repeat need 
# step13 Visualization of PPI
   iPath2(folder,quant)
   Network
   nq=quant[0]
   networks(folder, quant)
   os.system('sh /home/hxl/work/proteomics/needs/ppi.sh ' + folder + ' '+id + ' '+ nq.replace('/','-vs-'))
   parseStringLinks(folder+'/Network/'+nq.replace('/','-vs-')+'/string_interactions.tsv',folder+'/Network/'+nq.replace('/','-vs-')+'/blast.out', folder+'/Network/'+nq.replace('/','-vs-'), getRatioMap(folder,nq))
   analysisNetwork(folder+'/Network/'+nq.replace('/','-vs-'),folder,30)
####################################################################
ibrary(openxlsx)
library(stringr)
library(dplyr)
library(foreach)
suppressMessages(library(doParallel))
suppressMessages(library(doSNOW))
suppressMessages(library(car))
library(ggplot2)
library(reshape2)
library(ggrepel)
colpalette<-c("#1d953f", "#102b6a", "#c77eb5", "#ffce7b", "#2585a6", "purple", "#e0861a", "#d71345", "#6b473c", "#78a355", "#fdb933", "#5e7c85", "#411445", "#c37e00", "#bed742", "#009ad6", "#9d9087", "#aa2116", "#225a1f", "#f3715c", "#7bbfea", "#dbce8f", "#f8aba6", "#778899", "#2F4F4F", "#2E8B57", "#8B6969", "#EE2C2C", "#6495ED", "#87CEEB", "#0000CD", "#63B8FF", "#006400", "#00FF7F", "#9400D3", "#FFAEB9", "#8B5A2B", "#FFFF00", "#BDB76B", "#FF1493")
colpalette1<-c("#1d953f","#102b6a")

type <- "t"
axisR2X <- 0
thread <- 20

args <- commandArgs(T)
path <- args[1]

setwd(path) 
print(getwd())


Para <- read.xlsx("./Design/Parameters.xlsx", colNames = T, rowNames = T)
norm_method <- Para["normMethod",1]
scaling <- Para["scaleC",1]


if (scaling =="par"){
  scaleC <- "pareto"
}else if (scaling =="uv") {
  scaleC <- "standard"
}else if (scaling =="cen") {
  scaleC <- "center"
}else{
  scaleC <- "none"
}


if (type == "n"){
  ion <- args[7]
  if(ion == "pos"){
    ION <- "-POS"
  }else {
    ION <- "-NEG"
  }
  file <- tolower(paste0(ion, "-dele-iso.csv"))
  data <- read.csv(file,sep=",",header=TRUE,encoding='UTF-8',check.names=F,stringsAsFactors = FALSE)
  data <- subset(data,data$name!="")
  if(!is.na(args[8])&!is.na(args[9])){
    m <- as.numeric(args[8])
    n <- as.numeric(args[9])
  }else{
    m <- 1
    n <- 2
  }
  #output path
  Ionpath <- paste0(Statpath,"SIMCAP",ION,"/")
  dir.create(Ionpath)
  Ionpath_ci <- paste0(Statpath_ci,"SIMCAP",ION,"/")
  dir.create(Ionpath_ci)
  Ionpath_s <- paste0(Statpath_s,"SIMCAP",ION,"/")
  dir.create(Ionpath_s)
  Ionpath_s_ci <- paste0(Statpath_s_ci,"SIMCAP",ION,"/")
  dir.create(Ionpath_s_ci)
  picdatapath <- paste0(getwd(),"/picdata",ION,"/") 
  dir.create(picdatapath)
}else{
  ion <- "" 
  ION <- ""
  if(!is.na(args[7])&!is.na(args[8])){
    m <- as.numeric(args[7])
    n <- as.numeric(args[8])
  }else{
    m <- 1
    n <- 2
  }
  if (type == "l"){
    file <- "normeddata_for_simca.xlsx"
  }else{

    file <- "_file11.xlsx" 
  }
  
  internal_standards_pic <- function(file, path){
    data <- read.xlsx(file,colNames=T,check.names=F)

    data$QCRSD[is.na(data$QCRSD)] = 0
    data$QCRSD[data$QCRSD<0.01] = 0.01
   
    p = ggplot(data,aes(x=name,y=QCRSD))+geom_bar(stat="identity")
    p = p+labs(x=NULL,y="QCRSD",title="internal standards")
    p = p+theme(axis.text.x = element_text(angle = 45,hjust = 1))
    p = p+theme(plot.title = element_text(hjust = 0.5))
    p = p+theme(legend.title=element_blank(),legend.text=element_text(size = 5))
    ggsave(paste0(path, "/internal_standards.png"),p,height = 6,width = 10)
    ggsave(paste0(path, "/internal_standards.pdf"),p,height = 6,width = 10)
    print("xxxxxxxxxxxxpca ")
  }
  
  QCPath <- "1_QC/"
  dir.create(QCPath)
  
  if(file.exists("../../Attachment/IS.xlsx")){
      file2 = "../../Attachment/IS.xlsx"
      internal_standards_pic(file2, QCPath)
      
  }else{
    print("no ISfile!")
  }

  picdatapath <- paste0(getwd(),"/_picdata/")
  dir.create(picdatapath)
}


 filer_data  = function(data,inputname){
   for(eachG in  inputname$group[!duplicated(inputname$group)]){
     print(inputname[inputname$group == eachG,]$name)
     datatab = data[,colnames(data) %in% (inputname[inputname$group == eachG,]$name)]
     print(eachG)
     print(dim(datatab))
     print(head(datatab))
     boolist1 = apply(datatab,1,function (x) sum(is.na(x))>(length(x)/2))
     print(head(boolist1))
     print(length(boolist1))
     if (TRUE %in% boolist1){
     data = data[-which(boolist1),]
     }else{
     data = data
    }
     print(head(data))
   }
   print(head(data))
   rownames(data) <- seq(1,nrow(data),1)
   print("over")
   return(data)
 }

folders <- read.xlsx("Design/GroupVS.xlsx", colNames = T)
foldersall <- gsub("\\|", "_", folders[,1])

all_tab <- as.vector(folders[,1])
all_tab <- unlist(strsplit(as.character(all_tab),"_vs_|\\|",perl = TRUE)) %>% unique()

groupvs <- as.vector(folders[, 1])
sheetnames <- c()
sheetnames_txt <- c()
oneway <- c()
ttest <- c()
for (i in 1:length(groupvs)) {
  if(grepl("oneway", groupvs[i], perl = T)){
    oneway <- c(oneway, groupvs[i])
  }else ttest <- c(ttest, groupvs[i])
  if(all(nchar(groupvs) < 31)) {
    sheetnames[i] <- groupvs[i]
  }else{
    sheetnames[i] <- paste(i, str_sub(groupvs[i], end = (30-nchar(i))), sep = ".") 
    sheetnames_txt[i] <- paste0(i, ".", groupvs[i])
    #print(paste0("[", groupvs[i], "]", " is too long to write in sheetname!"))
    write.table(sheetnames_txt, "_Sheetnames.txt", sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE) 
    write.table(sheetnames, "_tempname.txt", sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)  
  }
}

  newname_0 <- read.xlsx("Design/Sample.xlsx", rowNames = F, check.names = F)
  inputname <- newname_0[, 3:4]
  
  names(inputname) <- c("name", "group")
  inputname <- inputname[order(inputname$group),]
  
  if ("QC" %in% inputname$group){
    inputname <- rbind(filter(inputname, group != "QC"), filter(inputname, group == "QC")) 
  }
  
  data <- read.xlsx(file,colNames=T,check.names=FALSE)
  colnames(data)[1] <- "name"
  
  if (all(unique(inputname[,1]) %in% colnames(data))){
    output <- cbind(data[,1:12],data[,inputname[,1]])
    write.xlsx(output,paste0(path,"/_file11.xlsx"),colNames=T)
  }else{
    select <- data[,newname_0[,2]]
    newname <- newname_0[match(colnames(select),newname_0[,2]),]$reportname
    colnames(select) <- newname
    output <- cbind(data[,1:12],select)
    write.xlsx(output,paste0(path,"/_file11.xlsx"),colNames=T)
    
  }
  
  
  
  data <- output
  alldata_QC <- data[,unique(inputname[,1])]
  data = filer_data(data,inputname)

print("page of 200")

alldata_QC <- sapply(alldata_QC, as.numeric)
if (norm_method == "sum") {
  
  alldata_QC <- as.matrix(alldata_QC)
  Sum <- apply(alldata_QC,2,sum,na.rm = TRUE) 
  for (i in 1:length(alldata_QC[1,])){
    alldata_QC[,i] <- alldata_QC[,i]/Sum[i]*1000
  }
}else if (norm_method == "log2"){  
  alldata_QC <- log2(alldata_QC)
}else if (norm_method == "log10"){
  alldata_QC <- log10(alldata_QC)
}else{
  alldata_QC <- alldata_QC
}

rownames(alldata_QC) <- data$name 

if(type != "l"){
  normdata <- data.frame(name = rownames(alldata_QC),alldata_QC,check.names = F)
  sty <- createStyle(fontName = "Arial", fontSize = 10)
  wb_mvda <- createWorkbook()
  addWorksheet(wb_mvda, sheet = "normeddata_for_simca",gridLines = TRUE)
  addStyle(wb_mvda,sheet = "normeddata_for_simca",sty,cols = 1:(ncol(normdata)+1),rows = 1:(nrow(normdata)+1),gridExpand = TRUE)
  writeData(wb_mvda,sheet ="normeddata_for_simca",normdata,colNames=TRUE,rowNames=FALSE)
  setColWidths(wb_mvda, sheet ="normeddata_for_simca", cols =1:ncol(normdata), widths = 10)
  saveWorkbook(wb_mvda,paste0(path,"/_normeddata_for_simca",ION,".xlsx"),overwrite =TRUE)
}

QCdata <- alldata_QC[,colnames(alldata_QC) %in% inputname[inputname$group== "QC",]$name]
QCdata[QCdata==0] <- NA 
QCdata <- log2(QCdata)
mmax <- max(QCdata,na.rm =TRUE)
mmin <- min(QCdata,na.rm =TRUE)
panel.cor <- function(x, y, digits = 3, prefix = "", cex.cor, ...)
{
  points(x,y,pch = 20)
  r <- abs(cor(x, y,use ="na.or.complete",method="pearson"))
  txt <- format(c(r, 0.123456789), digits = digits )[1]
  txt <- paste0(prefix, txt)
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
  text(0.3, 0.9, txt, cex = 1.2,col = "blue")
}
a <- ncol(QCdata)*4.5
png(filename = paste0(QCPath,"MultiScatter",ION,".png"),width = a,height = a,units = "cm",res = 300)
par(tck =0.05)
pairs(QCdata,upper.panel = panel.cor,lower.panel = panel.cor,gap=0.5,cex.axis = 0.8,xlim= c(mmin-1,mmax+1),ylim =c(mmin-1,mmax+1))
dev.off()


alldata <-alldata_QC[,colnames(alldata_QC) %in% inputname[inputname$group != "QC",]$name]
xMN_QC <- t(alldata_QC)
xMN <- t(alldata)
print("traitsxxx!")
samDF_QC <- inputname
samDF_QC[,1] <- as.character(samDF_QC[,1])
samDF_QC[,2] <- as.character(samDF_QC[,2])
samDF_QC[,1] <- factor(samDF_QC[,1],levels = unique(samDF_QC[,1]))
samDF_QC[,2] <- factor(samDF_QC[,2],levels = unique(samDF_QC[,2]))
samDF <- filter(samDF_QC, group != "QC")
samDF[,1] <- factor(samDF[,1],levels = unique(samDF[,1]))
samDF[,2] <- factor(samDF[,2],levels = unique(samDF[,2]))

kfold <- function(x){
  if ( nrow(x) >= 7){
    nn = 7
  }else{
    nn <- nrow(x)
  }
  return(nn)
}

Draw_score <- function(modelx = compute_pcaQC,picname = picname,xnumb = 1,ynumb = 2,outpath = Group_path,appearance = attribute_QC){
  if (picname == "OPLS-DA"){
    ploMN_out <- data.frame(getScoreMN(modelx),modelx@orthoScoreMN)
    ID <- rownames(ploMN_out)

    groupname = inputname
    colnames(groupname) = c("ID","group")
    ScoreMN <- data.frame(ID,ploMN_out,check.names=F)
    ScoreMN = merge(ScoreMN,groupname,by = "ID")
    modelDF_PP <- modelx@modelDF
    xlab1 <- paste0("PC1(",round(modelDF_PP[1,1]*100,2),"%)")
    ylab1 <- paste0("PC2(",round(modelDF_PP[2,1]*100,2),"%)")
    col <- c("#1d953f", "#102b6a", "#c77eb5", "#ffce7b", "#2585a6", "purple", "#e0861a",
                "#d71345", "#6b473c", "#78a355", "#fdb933", "#5e7c85", "#411445", "#c37e00",
                "#bed742", "#009ad6", "#9d9087", "#aa2116", "#225a1f", "#f3715c", "#7bbfea",
                "#dbce8f", "#f8aba6", "#778899", "#2F4F4F", "#2E8B57", "#8B6969", "#EE2C2C",
                "#6495ED", "#87CEEB", "#0000CD", "#63B8FF", "#006400", "#00FF7F", "#9400D3",
                "#FFAEB9", "#8B5A2B", "#FFFF00", "#BDB76B", "#FF1493","#0CA7B7","#F96A93")

   P_polt <- ggplot(data = ScoreMN,aes(x = p1,y = o1,color = ScoreMN$group))+

  stat_ellipse(aes(fill = ScoreMN$group),
               type = "norm",geom = "polygon",alpha = 0.25,color = NA)+
  geom_point(size = 3.5)+
  labs(x = xlab1,y = ylab1,color = "group",title = paste0(picname," Scores Plot"))+
  guides(fill = "none")+
  theme_bw()+
  geom_vline(xintercept = 0, color = 'gray', size = 0.4) +
  geom_hline(yintercept = 0, color = 'gray', size = 0.4) +
  scale_fill_manual(values = colpalette )+
  scale_colour_manual(values = col )+
  theme(plot.title = element_text(hjust = 0.5,size = 15),
        axis.text = element_text(size = 11),axis.title = element_text(size = 13),
        panel.grid = element_blank(),legend.text = element_text(size = 11),legend.title = element_text(size = 13),
        plot.margin = unit(c(0.4,0.4,0.4,0.4),'cm'),panel.background = element_rect(color = 'black', fill = 'transparent'),legend.key = element_rect(fill = 'transparent'))
  P_polt_label <- ggplot(data = ScoreMN,aes(x = p1,y = o1,color = ScoreMN$group))+

  stat_ellipse(aes(fill = ScoreMN$group),
               type = "norm",geom = "polygon",alpha = 0.25,color = NA)+

  geom_point(size = 3.5)+
  geom_text_repel(aes(label = ID), fontface = "bold") +
  labs(x = xlab1,y = ylab1,color = "group",title = paste0(picname," Scores Plot"))+
  guides(fill = "none")+
  theme_bw()+
  geom_vline(xintercept = 0, color = 'gray', size = 0.4) +
  geom_hline(yintercept = 0, color = 'gray', size = 0.4) +

  scale_fill_manual(values = colpalette )+
  scale_colour_manual(values = col )+
  theme(plot.title = element_text(hjust = 0.5,size = 15),
        axis.text = element_text(size = 11),axis.title = element_text(size = 13),
        panel.grid = element_blank(),legend.text = element_text(size = 11),legend.title = element_text(size = 13),
        plot.margin = unit(c(0.4,0.4,0.4,0.4),'cm'),panel.background = element_rect(color = 'black', fill = 'transparent'),legend.key = element_rect(fill = 'transparent'))
  ggsave(paste0(outpath,modelx@typeC,".pdf"), P_polt, width = 8, height = 6)
  ggsave(paste0(outpath,modelx@typeC,".png"), P_polt, width = 8, height = 6,dpi = 600)
  ggsave(paste0(outpath,modelx@typeC,"_label.pdf"), P_polt_label, width = 8, height = 6)
  ggsave(paste0(outpath,modelx@typeC,"_label.png"), P_polt_label, width = 8, height = 6,dpi = 600)
    
    colnames(ScoreMN)[3:4] <- c(paste0("PC1(", modelx@modelDF[1,1]*100, "%)"), 
                                paste0("PC2(", modelx@modelDF[2,1]*100, "%)"))
    save_file <- paste0(outpath,"_Score_",picname,".xlsx")
    openxlsx::write.xlsx(ScoreMN, save_file)
    message(paste0(save_file, " saved!!\n"))
    
    ploMN_out <- data.frame(ID,ploMN_out,check.names=F)
    write.table(ploMN_out,paste0(picdatapath,"Score_",picname,".xls"),sep = "\t",row.names = F)
    ploMN <- data.frame(p1 = getScoreMN(modelx),o1 = modelx@orthoScoreMN[,1])
    if (axisR2X == 0){
      xname = "t[1]"
      yname = "to[1]" 
    }else{
      xname = paste0("t[1] (",round(oplsda_g@modelDF[1, "R2X"] * 100),"%)")
      yname = "to[1]"
    }
  }else{
    ploMN <- getScoreMN(modelx)
    ID <- rownames(ploMN)
    ploMN_out <- data.frame(ID,ploMN,check.names=F)
    write.table(ploMN_out,paste0(picdatapath,"Score_",picname,".xls"),sep = "\t",row.names = F)
    groupname = inputname
    colnames(groupname) = c("ID","group")
    ScoreMN <- data.frame(ID,ploMN,check.names=F)
    ScoreMN = merge(ScoreMN,groupname,by = "ID")
    modelDF_PP <- modelx@modelDF
    xlab1 <- paste0("PC1(",round(modelDF_PP[1,1]*100,2),"%)")
    ylab1 <- paste0("PC2(",round(modelDF_PP[2,1]*100,2),"%)")
    zlab1 <- paste0("PC3(",round(modelDF_PP[3,1]*100,2),"%)")
    col <- c("#1d953f", "#102b6a", "#c77eb5", "#ffce7b", "#2585a6", "purple", "#e0861a",
                "#d71345", "#6b473c", "#78a355", "#fdb933", "#5e7c85", "#411445", "#c37e00",
                "#bed742", "#009ad6", "#9d9087", "#aa2116", "#225a1f", "#f3715c", "#7bbfea",
                "#dbce8f", "#f8aba6", "#778899", "#2F4F4F", "#2E8B57", "#8B6969", "#EE2C2C",
                "#6495ED", "#87CEEB", "#0000CD", "#63B8FF", "#006400", "#00FF7F", "#9400D3",
                "#FFAEB9", "#8B5A2B", "#FFFF00", "#BDB76B", "#FF1493","#0CA7B7","#F96A93")

 P_polt <- ggplot(data = ScoreMN,aes(x = p1,y = p2,color = ScoreMN$group))+

  stat_ellipse(aes(fill = ScoreMN$group),
               type = "norm",geom = "polygon",alpha = 0.25,color = NA)+

  geom_point(size = 3.5)+
  labs(x = xlab1,y = ylab1,color = "group",title = paste0(modelx@typeC," Scores Plot"))+
  guides(fill = "none")+
  theme_bw()+
  geom_vline(xintercept = 0, color = 'gray', size = 0.4) +
  geom_hline(yintercept = 0, color = 'gray', size = 0.4) +

  scale_fill_manual(values = colpalette )+
  scale_colour_manual(values = col )+
  theme(plot.title = element_text(hjust = 0.5,size = 15),
        axis.text = element_text(size = 11),axis.title = element_text(size = 13),
        panel.grid = element_blank(),legend.text = element_text(size = 11),legend.title = element_text(size = 13),
        plot.margin = unit(c(0.4,0.4,0.4,0.4),'cm'),panel.background = element_rect(color = 'black', fill = 'transparent'),legend.key = element_rect(fill = 'transparent'))


 P_polt_label <- ggplot(data = ScoreMN,aes(x = p1,y = p2,color = ScoreMN$group))+

  stat_ellipse(aes(fill = ScoreMN$group),
               type = "norm",geom = "polygon",alpha = 0.25,color = NA)+

  geom_point(size = 3.5)+
  geom_text_repel(aes(label = ID), fontface = "bold") +
  labs(x = xlab1,y = ylab1,color = "group",title = paste0(modelx@typeC," Scores Plot"))+
  guides(fill = "none")+
  theme_bw()+
  geom_vline(xintercept = 0, color = 'gray', size = 0.4) +
  geom_hline(yintercept = 0, color = 'gray', size = 0.4) +

  scale_fill_manual(values = colpalette )+
  scale_colour_manual(values = col )+
  theme(plot.title = element_text(hjust = 0.5,size = 15),
        axis.text = element_text(size = 11),axis.title = element_text(size = 13),
        panel.grid = element_blank(),legend.text = element_text(size = 11),legend.title = element_text(size = 13),
        plot.margin = unit(c(0.4,0.4,0.4,0.4),'cm'),panel.background = element_rect(color = 'black', fill = 'transparent'),legend.key = element_rect(fill = 'transparent'))
 ggsave(paste0(outpath,modelx@typeC,".pdf"), P_polt, width = 8, height = 6)#
 ggsave(paste0(outpath,modelx@typeC,".png"), P_polt, width = 8, height = 6,dpi = 600)
 ggsave(paste0(outpath,modelx@typeC,"_label.pdf"), P_polt_label, width = 8, height = 6)
 ggsave(paste0(outpath,modelx@typeC,"_label.png"), P_polt_label, width = 8, height = 6,dpi = 600)

    max_ncol <- ncol(ScoreMN)
    colnames(ScoreMN)[3:max_ncol] <- c(paste0("PC1(", modelx@modelDF[1,1]*100, "%)"), 
                                       paste0("PC2(", modelx@modelDF[2,1]*100, "%)"),
                                       paste0("PC3(", modelx@modelDF[3,1]*100, "%)")
    )[1:(max_ncol-2)]
###
Arg <- commandArgs(T)
path_0 <- as.character(Arg[1])
path <- paste0(path_0, "/3_Multivariate_Statistical_Analysis")
setwd(path)

library(openxlsx)
library(stringr)
library(dplyr)
options(stringsAsFactors = FALSE)

stytitle <- createStyle(fontSize = 10, fontName = "Times New Roman",textDecoration = "bold", fgFill = "#CCCCCC",halign="center",valign="center")
sty_center<-createStyle(halign="center",valign="center",fontName = "Times New Roman", fontSize = 10, border = "TopBottom", borderColour = "black",borderStyle = "medium")

dataN <-read.xlsx(xlsxFile ="R2Q2.xlsx")
colnames(dataN)[7] <- "Group"

tablePCA<-dataN[dataN$Type=="PCA",]
tablePCA<-tablePCA[-(1:2), ]
tablePCA <- tablePCA[,c(7,2,4)]
tablePCA$A <- as.numeric(tablePCA$A)
wb1 <- createWorkbook()
addWorksheet(wb1, sheet = "PCA" ,gridLines = TRUE, zoom = 120)
addStyle(wb1, sheet="PCA", sty_center,cols =1:ncol(tablePCA),rows =(1:nrow(tablePCA)+1),gridExpand = TRUE)
addStyle(wb1,sheet = "PCA",stytitle,cols =1:ncol(tablePCA),rows =1,gridExpand = TRUE)
writeData(wb1,sheet = "PCA",tablePCA ,colNames=TRUE,rowNames=FALSE)
setColWidths(wb1, sheet = "PCA", cols= 1:ncol(tablePCA), widths = c(nchar(tablePCA[1,1])+4,10,10))
saveWorkbook(wb1,"_pic_PCA.xlsx",overwrite =TRUE)


  tablePLSDA <- dataN[dataN$Type=="PLS-DA",]
  tablePLSDA <- tablePLSDA[,c(7,2,4:6)]
  tablePLSDA$A <- as.numeric(tablePLSDA$A)
  tablePLSDA$`R2Y(cum)` <- as.numeric(tablePLSDA$`R2Y(cum)`)
  tablePLSDA$`Q2(cum)` <- as.numeric(tablePLSDA$`Q2(cum)`)
  wb2 <- createWorkbook()
  addWorksheet(wb2, sheet = "PLS-DA" ,gridLines = TRUE,zoom = 120)
  addStyle(wb2, sheet="PLS-DA", sty_center,cols =1:ncol(tablePLSDA),rows =1:(nrow(tablePLSDA)+1),gridExpand = TRUE)
  addStyle(wb2,sheet = "PLS-DA",stytitle,cols =1:ncol(tablePLSDA),rows =1,gridExpand = TRUE)
  writeData(wb2,sheet = "PLS-DA",tablePLSDA ,colNames=TRUE,rowNames=FALSE)
  setColWidths(wb2, sheet = "PLS-DA", cols= 1:ncol(tablePLSDA), widths = c(nchar(tablePLSDA[1,1])+4,8,10,10,10))
  saveWorkbook(wb2,"_pic_PLSDA.xlsx",overwrite =TRUE)

  tableOPLSDA <- dataN[dataN$Type=="OPLS-DA",]
  tableOPLSDA <- tableOPLSDA[,c(7,2,4:6)]
  tableOPLSDA$`R2Y(cum)` <- as.numeric(tableOPLSDA$`R2Y(cum)`)
  tableOPLSDA$`Q2(cum)` <- as.numeric(tableOPLSDA$`Q2(cum)`)
  wb2 <- createWorkbook()
  addWorksheet(wb2, sheet = "OPLS-DA" ,gridLines = TRUE,zoom = 120)
  addStyle(wb2, sheet="OPLS-DA", sty_center,cols =1:ncol(tableOPLSDA),rows =1:(nrow(tableOPLSDA)+1),gridExpand = TRUE)
  addStyle(wb2,sheet = "OPLS-DA",stytitle,cols =1:ncol(tableOPLSDA),rows =1,gridExpand = TRUE)
  writeData(wb2,sheet = "OPLS-DA",tableOPLSDA ,colNames=TRUE,rowNames=FALSE)
  setColWidths(wb2, sheet = "OPLS-DA", cols= 1:ncol(tableOPLSDA), widths = c(nchar(tableOPLSDA[1,1])+4,8,10,10,10))
  saveWorkbook(wb2,"_pic_OPLSDA.xlsx",overwrite =TRUE)
  }

 # ### 3. differential analysis ####
H650Diff <- function(path){
  print("########## START DIFF ANALYSIS #######")
  library("openxlsx")
library("stringr")
library("dplyr")
library("reshape2")
library("ggplot2")

Arg <- commandArgs(T)
path <- as.character(Arg[1])
pairornot <- 0
options(stringsAsFactors = FALSE)
print(path)
setwd(path)

Para <- read.xlsx("./Design/Parameters.xlsx", rowNames = T, colNames = T)
project <- as.character(Para["types",1])
target_pro <- c("s", "l", "c")
types <- grep(project, target_pro)
Pvalue <- as.numeric(Para["pvalue",1])
FC <- as.numeric(Para["FC",1])
VIPvalue <- as.numeric(Para["VIP",1])
print(Pvalue)
print(FC)
print(VIPvalue)

Unit <- c("ng/g", "ng/mL", "pg")
UNION = Unit[types]


sty <- createStyle(fontName = "Arial", fontSize = 10)
stytitle <- createStyle(fontSize = 10, fontName = "Arial",textDecoration = "bold", halign = "left", fgFill = "#CCCCCC")


sty_color1 <- createStyle(fgFill = "yellow")
sty_color2 <- createStyle(fgFill = "#7EC0EE")

pan <- function(x){
  num <- length(x) - sum(is.na(x))
  if(num >= 2){
    return(na.omit(x))
  }else{
    return(na.omit(x))
  }
}

dir.create("4_Difference_Analysis")
dir.create("5_2_Hierarchical_Clustering_Analysis")
dir.create("5_3_KEGG_Analysis")

data.Extract <- function(dat, Group){
  print(head(dat))
  colnames(dat)[1] = "Name"
  
  tab <- unlist(strsplit(gsub("_oneway", "", as.character(Group)),"_vs_|\\_",perl = TRUE))
  
  folder <- gsub('\\|', '_', Group)
  outpath_clu <- paste("5_2_Hierarchical_Clustering_Analysis", folder, sep = "/")
  if(!dir.exists(outpath_clu)) dir.create(outpath_clu)
  print(head(dat))  
  print(tab)

  outpath_vol <- paste0("4_Difference_Analysis/", folder)
  if(grepl("_vs_", outpath_vol)){
    if(!dir.exists(outpath_vol)) dir.create(outpath_vol)
    }
  
  if(length(tab) == 2){
    
    data_sig <- dat[!is.na(dat$Name)  & dat$pvalue< Pvalue & dat$VIP > VIPvalue & abs(log2(dat$Foldchange)) >  log2(FC),]
  }else{
    
    data_sig <- dat[!is.na(dat$Name) &  dat$pvalue < Pvalue,]
  } 
  data_clu <- data.frame(Name = data_sig$Name)
  for(j in 1:length(tab)){
    data_clu <- data.frame(data_clu, data_sig[, colnames(data_sig) %in% inputname[which(inputname$group == tab[j]),1]], check.names = F)
  }
      print(paste(outpath_vol, "_1.txt", sep = "/"))
  data_clu = data_clu[!duplicated(data_clu$Name),]
  if(grepl("_vs_", outpath_vol, perl = TRUE)){
    write.table(data_clu, file = paste(outpath_vol, "_1.txt", sep = "/"), row.names = F, quote = F, sep = "\t")
  }else{
    write.table(data_clu, file = paste0(path, "/4_Difference_Analysis/_", folder, "_1.txt"), row.names = F, quote = F, sep = "\t")
    
  }

  print("KEGG数据提取！！！！！！！！beging") 
  outpath_keg <- paste0("5_3_KEGG_Analysis/", folder)
  if(!dir.exists(outpath_keg)) dir.create(outpath_keg)
  
  if(length(tab) == 2){
    data_kegg <- select(data_sig, Name, MEAN,KEGG,FC = 'Foldchange', 'pvalue')
    
    META_UP <- data_kegg[data_kegg$FC > FC,][,c("Name","KEGG")]
    META_DOWN <- data_kegg[data_kegg$FC < 1/FC,][,c("Name","KEGG")]
    
    
	write.table(META_UP, paste(outpath_keg, "_META_up.txt", sep = "/"), col.names = F, row.names = F, sep = "\t", quote = F)
    
	write.table(META_DOWN, paste(outpath_keg, "_META_down.txt", sep = "/"), col.names = F, row.names = F, sep = "\t", quote = F)
  }else{
    data_kegg <- select(data_sig, Name,MEAN, KEGG,'p-value' = 'pvalue')
  } 
  
  META_diff <- data_kegg[,c("Name","KEGG")]
  
  write.table(META_diff, paste(outpath_keg, "_diff.txt", sep = "/"), col.names = F, row.names = F, sep = "\t", quote = F)
  
  write.table(data_kegg, file = paste(outpath_keg, paste0("_info-", "H650", ".txt"), sep = "/"), row.names = F, quote = F, sep = "\t")
  
  if(file.exists(paste0(outpath_keg, "/_info-H650.txt"))){
    
    input2 <- read.table(paste0(outpath_keg, "/_info-H650.txt"), sep = "\t", header = TRUE, encoding = 'UTF-8', check.names = F, stringsAsFactors = FALSE, quote = "")
   
    data <- input2
    data1 <- data %>% group_by(Name) %>% arrange(desc(MEAN))
    data_temp <- data1
    data_temp$Name <- tolower(data_temp$Name)
    index <- duplicated(data_temp$Name)
    data1$Name[index] <- NA
    data1 <- data1[order(data1$Name), -2]
    data_out <- data1[!is.na(data1$Name),]
    write.table(data_out, paste(outpath_keg, "_info-diff.txt", sep = "/"), col.names = TRUE, row.names = FALSE, quote = FALSE, sep = "\t")
  }
  
  if(length(tab) == 2){
    outpath_vol <- paste0("4_Difference_Analysis/", folder)
    if(!dir.exists(outpath_vol)) dir.create(outpath_vol)
    data_vol <- select(dat, FC = 'Foldchange', Pvalue = 'pvalue')
    data_vol <- na.omit(data_vol)
    write.csv(data_vol, file = paste(outpath_vol, "_diff.csv", sep = "/"), row.names = F)
  }
}

database <- read.table("D:\\Commoncodes\\Commoncodes\\03.Non-targeted\\Non-targeted-Routine\\metabo_HMDB_database.txt",sep="\t",header = T,na.strings = "NA",strip.white = TRUE,stringsAsFactors = F,quote = "",fileEncoding = "UTF-8")

groupvs <- read.xlsx("./Design/GroupVS.xlsx", colNames = T)
groupvs <- as.vector(groupvs[, 1])

if(all(nchar(groupvs) < 31)){
  sheetname <- groupvs
}else{
  sheetname <- as.vector(read.table("_tempname.txt", header = FALSE, sep = "\t", quote = "")[, 1])
}


newname_0 <- read.xlsx("Design/Sample.xlsx", rowNames = F, check.names = F)
inputname <- newname_0[, 3:4]
names(inputname) <- c("name", "group")
inputname <- inputname[order(inputname$group),]
  
  if ("QC" %in% inputname$group){
    inputname <- rbind(filter(inputname, group != "QC"), filter(inputname, group == "QC")) 
  }

  
  QCPath <- paste0("1_QC/")

  file <- "_file12.xlsx"
  data <- read.xlsx(file,colNames = T, check.names=FALSE)
  colnames(data)[1] <- "name"
  data <- subset(data, data$name!="")
  
  if (all(unique(inputname[,1]) %in% colnames(data))){
    output <- cbind(data[,1:12],data[,inputname[,1]])

  }else{
    select <- data[,newname_0[,2]]
    newname <- newname_0[match(colnames(select),newname_0[,2]),]$reportname
    colnames(select) <- newname
    output <- cbind(data[,1:12],select)
    
  }
  
    RSD <- function(x){
      m <- mean(x,na.rm=TRUE)
      s <- sd(x,na.rm=TRUE)
      RSD <- s/m
      return(RSD=RSD)
    }
    data <-output
    QC <- data[,as.vector(inputname[which(inputname$group == "QC"),1])]
    QC[QC =="N/A"] <- NA
    QC[QC =="NA"] <- NA
    QC_RSD <- as.matrix(apply(QC,1,RSD)) %>% as.numeric()
    data$QCRSD <- QC_RSD
  write.xlsx(data,paste0(path,"/_file12.xlsx"),colNames=T)
  QC_curve <- dplyr::select(data,name,contains("RSD",ignore.case = T))
  colnames(QC_curve)[2] <- "QCRSD"
  print("d")
  QC_curve$QCRSD <- QC_curve$QCRSD*100

  print(head(QC_curve))
  pdata<-table(QC_curve$QCRSD)
  print(head(pdata))
  pframe<-data.frame(as.numeric(names(pdata)),as.numeric(pdata))
  colnames(pframe)<-c("QCRSD","num")
  rankData<-pframe[order(pframe[,1],decreasing=F),]
  mulData<-data.frame()
  sum=0
  for(i in 1:nrow(rankData)){
    sum=sum+rankData[i,2]
    row=cbind(rankData$QCRSD[i],sum)
    mulData=rbind(mulData,row)
  }      
  colnames(mulData)<-c("QCRSD","num")
  curve_Data <-data.frame(RSD =mulData$QCRSD,PER =mulData$num/sum*100)
  print(head(curve_Data))
  print(dim(curve_Data))
  
  pc <- ggplot(curve_Data)+
    geom_line(aes(x = RSD, y = PER),colour = "orange",size = 0.5) +
    geom_smooth(aes(x = RSD, y = PER),colour = "orange",size = 0.5,method='lm',formula=y~I(poly(x,20))) +
    scale_x_continuous(breaks = c(0,30,50,100,200))+
    theme_bw() + 
    theme(panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          axis.line=element_line(size=0.4,colour="black"),
          axis.text.x=element_text(colour="black",size = 10), 
          axis.text.y=element_text(colour="black",size = 10), 
          axis.title.x=element_text(size = 12), 
          axis.title.y=element_text(size = 12)
    )+
    geom_vline(xintercept = 30,lty =2, colour = "grey")+
    ylab("% of peaks") +
    xlab("RSD (%)") 
  print(QCPath)
  ggsave(file = paste0(QCPath,"QCRSD_curve",".png"),pc,width = 10, height = 10, units = "cm",dpi=300)
  
  print("hello")


Non_tar_step1 <- function(ion){
  MVDApath <- paste0(path,"/3_Multivariate_Statistical_Analysis/")
  
  if(!file.exists("significanceA.txt")&!file.exists("significanceB.txt")){
    file.copy(paste0(MVDApath,"QC.png"),QCPath)
    file.copy(paste0(MVDApath,"MCC.png"),QCPath)
    file.copy(paste0(MVDApath,"MultiScatter.png"),QCPath)
    
    MVDApath2 <- paste0(path,"/3_Multivariate_Statistical_Analysis/")
    dir.create(MVDApath2,recursive = T,showWarnings = F)
    
    
    file.copy(paste0(MVDApath,list.files(MVDApath,include.dirs = TRUE)),MVDApath2)
   
    setwd(MVDApath2)
 
    file.copy(paste0(MVDApath,list.files(MVDApath,include.dirs = TRUE)),MVDApath2)
    setwd(MVDApath2)
    file.remove("warning.txt","Hotelling-s T2Range Line Plot.png","MCC.png")
    setwd(path)
  }
 


  file = paste0(path,"/_file12.xlsx")

  data <- read.xlsx(file, colNames = T, check.names=FALSE)
  colnames(data)[1] <- "Name"
  
  wb2 <- createWorkbook()
  for(i in seq(length(groupvs))){
    print(paste0(i, ".", groupvs[i]))
    
    folder <- gsub('\\|', '_', groupvs[i])

    tab <- unlist(strsplit(gsub("_oneway", "", as.character(groupvs[i])),"_vs_|\\_",perl = TRUE))

    file2 <- paste0(MVDApath,"/_VIP.xlsx")

    print("page 321")

    data_tab <- seq(nrow(data))
    Replicated <- c()
    for (j in 1:length(tab)) {
      Replicated <- c(Replicated, sum(colnames(data) %in% inputname[which(inputname$group == tab[j]),1]))
      data_tab <- data.frame(data_tab,data[, colnames(data) %in% inputname[which(inputname$group == tab[j]),1]],
                             stringsAsFactors = FALSE, check.names = FALSE)
    }

    data_tab <- subset(data_tab, select = -data_tab)
    
    MEAN <- rowMeans(data_tab, na.rm = TRUE)

    outfiles <- list.files(path = paste0(MVDApath2, "/", folder), pattern = "xlsx", full.names = TRUE)
    if("TRUE" %in% grepl("\\~\\$",outfiles)){
      outfiles <- outfiles[-grep("^\\~\\$", outfiles)]
    }
    
    if(length(tab) == 2){
      outpfile <- outfiles[grep(paste0("H650", "/significance"), outfiles)]
    }else outpfile <- outfiles[grep(paste0("H650", "/twoway"), outfiles)]
    print("page 341!!!!!!!!!!!")
    OUTP <- FALSE
    if(length(outpfile) != 0){
      print("xxxxxxx===0")
      outp_data <- read.xlsx(outpfile, check.names = F)
      Index <- match(data$ID, outp_data$ID)
      outp_data <- outp_data[Index,]
      out_pvalue <- outp_data[,ncol(outp_data)]
      OUTP <- TRUE
    }
    
    pvalue <- c()
    if(length(tab) == 2){
      print("page 354")
      Foldchange <- c()
      for(m in seq(nrow(data))){
        A1 <- as.numeric(data[m, colnames(data) %in% inputname[which(inputname$group == tab[1]),1]])
        A2 <- as.numeric(data[m, colnames(data) %in% inputname[which(inputname$group == tab[2]),1]])
        if(sum(is.na(A1)) < ceiling(Replicated[1]/2) && sum(is.na(A2)) < ceiling(Replicated[2]/2)){
          Foldchange[m] <- c(mean(A1, na.rm = TRUE) / mean(A2, na.rm = TRUE))
          if(OUTP){
            pvalue[m] <- out_pvalue[m]
          }else{

            if(pairornot == 0){
              pvalue[m] <- c(t.test(A1, A2, alternative = "two.side", var.equal = TRUE)$p.value)
            }else pvalue[m] <- c(t.test(A1, A2, alternative = "two.side", var.equal = TRUE, paired = TRUE)$p.value)
          }
        }else{
          pvalue[m] <- 1
          Foldchange[m] <- NA
        }
      }

      print("page 373!!!")
      sigsig<- data.frame(Foldchange, pvalue, MEAN)
      rawdata1 <- cbind(data, sigsig)
    
      print("page 376!!!!!")
      data1 <- read.xlsx(xlsxFile = file2, sheet = sheetname[i], colNames = T, check.names = F)
      colnames(data1)[1] <- "Name"
      dataVIP <- data.frame(Name = data1[,1], VIP = data1$VIP_oplsda)
     
      print("page 380 !!!!!!!")

      rawdata1 <- merge(rawdata1, dataVIP, by = "Name")
      print("page 385 !!!!!!!!!!")
      difflist <- rep("-",nrow(rawdata1))
    
      difflist[which(rawdata1$VIP > VIPvalue & rawdata1$pvalue < Pvalue & abs(log2(rawdata1$Foldchange)) >  log2(FC))] = "diff"
      rawdata1$diff = difflist
      print("page 388")
    
    }else{
      print("page 391!!!")
        post_hoc <- c()
        log_data_tab <- log2(data_tab)
        for(m in 1:nrow(log_data_tab)){
          x <- c()
          A <- c()
          num <- 0
          for (j in seq(length(tab))){
            sample_data <- log_data_tab[, colnames(log_data_tab) %in% inputname[which(inputname$group == tab[j]),1]][m,]
            gp<-pan(as.numeric(sample_data))
            if(length(gp) >= 2){
              num = num+1
              x <- c(x, gp)
              A <- c(A, rep(tab[j], length(gp)))
            }
          }
          if(num >= 2){
            A <- factor(A)
            lamp <- data.frame(x, A)
            lamp.acv <- aov(x ~ A, data = lamp)
            a <- summary(lamp.acv)
            pvalue[m] <- a[[1]]$`Pr(>F)`[1]
            post <- TukeyHSD(lamp.acv)
            result <- ""
            if(OUTP) pvalue[m] <- out_pvalue[m]

            for(n in 1:nrow(post$A)){
              if(post$A[n, 4] < Pvalue){
                result <- paste(result, row.names(post$A)[n], sep = ";")
              }
            }
          }else pvalue[m] <- 1

          if(result == "" | pvalue[m] > Pvalue){
            post_hoc[m] <- "/"
          }else{
            post_hoc[m] <- substring(result, 2)
          }
      }
      sigsig<- data.frame(pvalue, MEAN, post_hoc)
      rawdata1 <- cbind(data, sigsig)
      rawdata1$diff <- as.factor(ifelse(!is.na(rawdata1$Name) & rawdata1$pvalue < Pvalue, "diff", NA))
    }


    rawdata1 <- rawdata1[order(rawdata1$Name),]
    sty <- createStyle(fontName = "Arial", fontSize = 10)
    
    addWorksheet(wb2, sheet = sheetname[i], gridLines = TRUE)
    addStyle(wb2, sheet = sheetname[i], sty, cols = 1:(ncol(rawdata1)+1),
             rows = 1:(nrow(rawdata1)+1), gridExpand = TRUE)
    writeData(wb2, sheet = sheetname[i], rawdata1, colNames = TRUE, rowNames = FALSE)
    setColWidths(wb2, sheet = sheetname[i], cols = 1:ncol(rawdata1), widths = "auto")
  }
 saveWorkbook(wb2, paste("_H650", ".xlsx", sep = ""), overwrite = TRUE)
  print("vip over")
}
print("page 450!!!!!!!!!!!")
Non_tar_step2 <- function(condition = FALSE){
  if(condition){
